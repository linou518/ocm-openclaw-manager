const express = require('express');
const nodeManagementRouter = require('./node-management-api');
const cors = require('cors');
const path = require('path');
const Database = require('better-sqlite3');

const app = express();
const PORT = 8001;

// Database
const dbPath = path.join(__dirname, 'db', 'ocm.db');
const db = new Database(dbPath);
db.pragma('journal_mode = WAL');

// Middleware
app.use(cors());
app.use(express.json());

// Á¶ÅÁî®APIÁºìÂ≠òÔºåÈò≤Ê≠¢ÂâçÁ´ØÁºìÂ≠òÈóÆÈ¢ò
app.use('/api', (req, res, next) => {
  res.set({
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache', 
    'Expires': '0'
  });
  next();
});

// API Routes
app.use(nodeManagementRouter);

// Dashboard - ÂÖ®ÈáèÊï∞ÊçÆ
app.get('/api/dashboard', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes ORDER BY id').all();
    
    // ÊØè‰∏™ËäÇÁÇπÊ∑ªÂä† bot Êï∞Èáè
    nodes.forEach(node => {
      const botCount = db.prepare('SELECT COUNT(*) as count FROM bots WHERE node_id = ?').get(node.id).count;
      node.bot_count = botCount;
    });
    
    const events = db.prepare('SELECT * FROM events ORDER BY created_at DESC LIMIT 10').all();
    
    const onlineCount = nodes.filter(n => ['online', 'unstable'].includes(n.status)).length;
    const avgScore = Math.floor(
      nodes.filter(n => n.last_score).reduce((sum, n) => sum + n.last_score, 0) / 
      nodes.filter(n => n.last_score).length
    ) || 0;
    
    const todayBackups = db.prepare(`
      SELECT COUNT(*) as count FROM backups 
      WHERE created_at > ?
    `).get(Date.now() - 86400000).count;

    // Êô∫ÂäõË∂ãÂäøÊï∞ÊçÆÔºàÊúÄËøë7Â§©Ôºâ
    const sevenDaysAgo = Date.now() - 7 * 24 * 3600000;
    const trendScores = db.prepare(`
      SELECT node_id, total_score, created_at 
app.get("/api/test-joe-simple", (req, res) => res.json({ message: "Hello from Joe!" }));
      FROM scores 
      WHERE created_at > ?
      ORDER BY created_at ASC
    `).all(sevenDaysAgo);

    // ÊåâÊó•ÊúüÂàÜÁªÑ
    const trendMap = {};
    trendScores.forEach(score => {
      const date = new Date(score.created_at).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' });
      if (!trendMap[date]) trendMap[date] = {};
      trendMap[date][score.node_id] = score.total_score;
    });

    const trendData = Object.keys(trendMap).map(date => ({
      date,
      ...trendMap[date]
    }));

    // Phase 7: Additional stats
    const totalSessions = db.prepare('SELECT COUNT(*) as count FROM sessions').get().count;
    const activeSessions = db.prepare('SELECT COUNT(*) as count FROM sessions WHERE is_active = 1').get().count;
    const totalCronJobs = db.prepare('SELECT COUNT(*) as count FROM cron_jobs').get().count;
    const enabledCronJobs = db.prepare('SELECT COUNT(*) as count FROM cron_jobs WHERE enabled = 1').get().count;
    const totalSkills = db.prepare('SELECT COUNT(*) as count FROM skills').get().count;
    const memoryWarnings = db.prepare(`
      SELECT COUNT(*) as count FROM memory_health 
      WHERE health_status != 'healthy' 
      AND id IN (
        SELECT MAX(id) FROM memory_health GROUP BY bot_id
      )
    `).get().count;

    res.json({
      overview: {
        totalNodes: nodes.length,
        onlineCount,
        offlineCount: nodes.length - onlineCount,
        avgScore,
        todayBackups,
        alerts: nodes.filter(n => n.last_score && n.last_score < 80).length,
        totalSessions,
        activeSessions,
        totalCronJobs,
        enabledCronJobs,
        totalSkills,
        memoryWarnings,
      },
      nodes,
      events,
      trendData,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπÂàóË°®
app.get('/api/nodes', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes ORDER BY id').all();
    res.json(nodes);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†ËäÇÁÇπ (Phase 6 CRUD)
app.post('/api/nodes', async (req, res) => {
  try {
    const { id, name, host, port, ssh_user, openclaw_path, auto_install } = req.body;
    
    // 1. ÂÖàÊ∑ªÂä†ËäÇÁÇπÂà∞Êï∞ÊçÆÂ∫ì
    const result = db.prepare(`
      INSERT INTO nodes (id, name, host, port, ssh_user, openclaw_path, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      id, 
      name, 
      host, 
      port || 22, 
      ssh_user || 'openclaw', 
      openclaw_path || '/home/openclaw/.openclaw', 
      auto_install ? 'installing' : 'unknown', 
      Date.now(), 
      Date.now()
    );
    
    const newNode = db.prepare('SELECT * FROM nodes WHERE id = ?').get(id);
    
    // 2. Â¶ÇÊûúÂêØÁî®Ëá™Âä®ÂÆâË£ÖÔºåËß¶ÂèëÂêéÂè∞ÂÆâË£Ö
    if (auto_install) {
      console.log(`üöÄ Ëß¶ÂèëËá™Âä®ÂÆâË£Ö: ${id} (${host})`);
      
      // ÂàõÂª∫ÂÆâË£Ö‰∫ã‰ª∂ËÆ∞ÂΩï
      db.prepare(`
        INSERT INTO events (node_id, type, severity, message, created_at)
        VALUES (?, 'install', 'info', ?, ?)
      `).run(id, `ÂºÄÂßãËá™Âä®ÂÆâË£Ö OpenClaw Âà∞ËäÇÁÇπ ${name}`, Date.now());
      
      // ÂºÇÊ≠•ÊâßË°åÂÆâË£ÖÔºà‰∏çÈòªÂ°ûÂìçÂ∫îÔºâ
      setImmediate(() => {
        installOpenClawToNode(newNode);
      });
    }
    
    res.json(newNode);
  } catch (error) {
    console.error('Ê∑ªÂä†ËäÇÁÇπÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞ËäÇÁÇπ (Phase 6 CRUD)
app.put('/api/nodes/:id', (req, res) => {
  try {
    const { name, host, port, ssh_user, openclaw_path, tags } = req.body;
    db.prepare(`
      UPDATE nodes 
      SET name = ?, host = ?, port = ?, ssh_user = ?, openclaw_path = ?, tags = ?, updated_at = ?
      WHERE id = ?
    `).run(name, host, port, ssh_user, openclaw_path, tags, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êü•ËØ¢ËäÇÁÇπÂÆâË£ÖÁä∂ÊÄÅ
app.get('/api/nodes/:id/install-status', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }
    
    // Ëé∑ÂèñÊúÄËøëÁöÑÂÆâË£ÖÁõ∏ÂÖ≥‰∫ã‰ª∂
    const events = db.prepare(`
      SELECT * FROM events 
      WHERE node_id = ? AND type IN ('install', 'health') 
      ORDER BY created_at DESC 
      LIMIT 5
    `).all(req.params.id);
    
    res.json({
      node: {
        id: node.id,
        name: node.name,
        status: node.status,
        openclaw_version: node.openclaw_version,
        last_seen_at: node.last_seen_at
      },
      events: events,
      installing: node.status === 'installing'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§ËäÇÁÇπ (Phase 6 CRUD)
app.delete('/api/nodes/:id', (req, res) => {
  try {
    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ≥ËÅîÊï∞ÊçÆ
    const botsCount = db.prepare('SELECT COUNT(*) as count FROM bots WHERE node_id = ?').get(req.params.id).count;
    const keysCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE node_id = ?').get(req.params.id).count;
    
    if (botsCount > 0 || keysCount > 0) {
      return res.status(400).json({ 
        error: `ËØ•ËäÇÁÇπ‰∏ãËøòÊúâ ${botsCount} ‰∏™ Bot Âíå ${keysCount} ‰∏™ KeyÔºåÊó†Ê≥ïÂà†Èô§` 
      });
    }
    
    db.prepare('DELETE FROM nodes WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπËØ¶ÊÉÖ
app.get('/api/nodes/:id', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) {
      return res.status(404).json({ error: 'Node not found' });
    }

    const backups = db.prepare(`
      SELECT * FROM backups WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 10
    `).all(req.params.id);

    const scores = db.prepare(`
      SELECT * FROM scores WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 10
    `).all(req.params.id);

    const events = db.prepare(`
      SELECT * FROM events WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 20
    `).all(req.params.id);

    res.json({ node, backups, scores, events });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Â§á‰ªΩÂàóË°®
app.get('/api/nodes/:id/backups', (req, res) => {
  try {
    const backups = db.prepare(`
      SELECT * FROM backups WHERE node_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.id);
    res.json(backups);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êô∫ÂäõËØÑÂàÜÂéÜÂè≤
app.get('/api/nodes/:id/scores', (req, res) => {
  try {
    const scores = db.prepare(`
      SELECT * FROM scores WHERE node_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.id);
    res.json(scores);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ‰∫ã‰ª∂Êó•Âøó (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/events', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, severity, type, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (severity && severity !== 'all') {
      whereClause.push('severity = ?');
      params.push(severity);
    }
    if (type && type !== 'all') {
      whereClause.push('type = ?');
      params.push(type);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM events ${whereSQL}`).get(...params).count;
    const events = db.prepare(`
      SELECT * FROM events 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: events,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈÉ®Â§á‰ªΩ (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/backups', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, type, is_stable, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (type && type !== 'all') {
      whereClause.push('type = ?');
      params.push(type);
    }
    if (is_stable === '1') {
      whereClause.push('is_stable = 1');
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM backups ${whereSQL}`).get(...params).count;
    const backups = db.prepare(`
      SELECT * FROM backups 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: backups,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§Â§á‰ªΩ (Phase 6 CRUD)
app.delete('/api/backups/:id', (req, res) => {
  try {
    db.prepare('DELETE FROM backups WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÁªôÂ§á‰ªΩÊ∑ªÂä†Ê†áÁ≠æ (Phase 6)
app.put('/api/backups/:id/tag', (req, res) => {
  try {
    const { git_tag, is_stable } = req.body;
    db.prepare(`
      UPDATE backups 
      SET git_tag = ?, is_stable = ?
      WHERE id = ?
    `).run(git_tag, is_stable ? 1 : 0, req.params.id);
    
    const updated = db.prepare('SELECT * FROM backups WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈÉ®ËØÑÂàÜÂéÜÂè≤ (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/scores/all', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, minScore, maxScore, action_taken, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (minScore) {
      whereClause.push('total_score >= ?');
      params.push(parseInt(minScore));
    }
    if (maxScore) {
      whereClause.push('total_score <= ?');
      params.push(parseInt(maxScore));
    }
    if (action_taken && action_taken !== 'all') {
      whereClause.push('action_taken = ?');
      params.push(action_taken);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM scores ${whereSQL}`).get(...params).count;
    const scores = db.prepare(`
      SELECT * FROM scores 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: scores,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Accounts ÁÆ°ÁêÜ ============

// Ëé∑ÂèñÊâÄÊúâË¥¶Âè∑
app.get('/api/accounts', (req, res) => {
  try {
    const accounts = db.prepare('SELECT * FROM accounts ORDER BY provider, id').all();
    
    // ÊØè‰∏™Ë¥¶Âè∑Ê∑ªÂä† key Êï∞Èáè
    accounts.forEach(account => {
      const keyCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE account_id = ?').get(account.id).count;
      account.key_count = keyCount;
    });
    
    res.json(accounts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†Ë¥¶Âè∑
app.post('/api/accounts', (req, res) => {
  try {
    const { provider, account_name, email, plan, monthly_budget, status, note } = req.body;
    const result = db.prepare(`
      INSERT INTO accounts (provider, account_name, email, plan, monthly_budget, status, note)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(provider, account_name, email || '', plan || 'free', monthly_budget || 0, status || 'active', note || '');
    
    const newAccount = db.prepare('SELECT * FROM accounts WHERE id = ?').get(result.lastInsertRowid);
    res.json(newAccount);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞Ë¥¶Âè∑
app.put('/api/accounts/:id', (req, res) => {
  try {
    const { account_name, email, plan, monthly_budget, monthly_used, status, note } = req.body;
    db.prepare(`
      UPDATE accounts 
      SET account_name = ?, email = ?, plan = ?, monthly_budget = ?, monthly_used = ?, status = ?, note = ?, updated_at = ?
      WHERE id = ?
    `).run(account_name, email, plan, monthly_budget, monthly_used, status, note, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM accounts WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§Ë¥¶Âè∑
app.delete('/api/accounts/:id', (req, res) => {
  try {
    // ÂÖàÊ£ÄÊü•ÊòØÂê¶ÊúâÂÖ≥ËÅîÁöÑkeys
    const keyCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE account_id = ?').get(req.params.id).count;
    if (keyCount > 0) {
      return res.status(400).json({ error: 'ËØ•Ë¥¶Âè∑‰∏ãËøòÊúâ API KeysÔºåÊó†Ê≥ïÂà†Èô§' });
    }
    
    db.prepare('DELETE FROM accounts WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ëé∑ÂèñË¥¶Âè∑‰∏ãÁöÑÊâÄÊúâkeys
app.get('/api/accounts/:id/keys', (req, res) => {
  try {
    const keys = db.prepare('SELECT * FROM api_keys WHERE account_id = ? ORDER BY created_at DESC').all(req.params.id);
    res.json(keys);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ API Keys ÁÆ°ÁêÜ ============

// Ëé∑ÂèñËäÇÁÇπÁöÑÊâÄÊúâkeys
app.get('/api/nodes/:id/keys', (req, res) => {
  try {
    const keys = db.prepare('SELECT * FROM api_keys WHERE node_id = ? ORDER BY created_at DESC').all(req.params.id);
    res.json(keys);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†key
app.post('/api/nodes/:id/keys', (req, res) => {
  try {
    const { provider, key_name, api_key, monthly_limit, note } = req.body;
    const result = db.prepare(`
      INSERT INTO api_keys (node_id, provider, key_name, api_key, monthly_limit, note)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(req.params.id, provider, key_name, api_key, monthly_limit || null, note || '');
    
    const newKey = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(result.lastInsertRowid);
    res.json(newKey);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞key
app.put('/api/keys/:keyId', (req, res) => {
  try {
    const { key_name, api_key, is_active, monthly_limit, note } = req.body;
    db.prepare(`
      UPDATE api_keys 
      SET key_name = ?, api_key = ?, is_active = ?, monthly_limit = ?, note = ?, updated_at = ?
      WHERE id = ?
    `).run(key_name, api_key, is_active, monthly_limit, note, Date.now(), req.params.keyId);
    
    const updated = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(req.params.keyId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§key
app.delete('/api/keys/:keyId', (req, res) => {
  try {
    db.prepare('DELETE FROM api_keys WHERE id = ?').run(req.params.keyId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// È™åËØÅkey
app.post('/api/keys/:keyId/verify', (req, res) => {
  try {
    // Mock: ÈöèÊú∫ËøîÂõû valid/invalid
    const status = Math.random() > 0.2 ? 'valid' : 'invalid';
    db.prepare(`
      UPDATE api_keys 
      SET status = ?, last_verified_at = ?
      WHERE id = ?
    `).run(status, Date.now(), req.params.keyId);
    
    const updated = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(req.params.keyId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§keyÂàóË°® (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/keys', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { provider, account_id, node_id, status } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (provider && provider !== 'all') {
      whereClause.push('k.provider = ?');
      params.push(provider);
    }
    if (account_id && account_id !== 'all') {
      whereClause.push('k.account_id = ?');
      params.push(parseInt(account_id));
    }
    if (node_id && node_id !== 'all') {
      whereClause.push('k.node_id = ?');
      params.push(node_id);
    }
    if (status && status !== 'all') {
      whereClause.push('k.status = ?');
      params.push(status);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`
      SELECT COUNT(*) as count 
      FROM api_keys k
      LEFT JOIN accounts a ON k.account_id = a.id
      ${whereSQL}
    `).get(...params).count;
    
    const keys = db.prepare(`
      SELECT k.*, a.account_name, a.plan 
      FROM api_keys k
      LEFT JOIN accounts a ON k.account_id = a.id
      ${whereSQL}
      ORDER BY k.node_id, k.provider
      LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: keys,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Bots ÁÆ°ÁêÜ ============

// Ëé∑ÂèñËäÇÁÇπÁöÑÊâÄÊúâbots
app.get('/api/nodes/:id/bots', (req, res) => {
  try {
    const bots = db.prepare('SELECT * FROM bots WHERE node_id = ? ORDER BY created_at').all(req.params.id);
    res.json(bots);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†bot
app.post('/api/nodes/:id/bots', (req, res) => {
  console.log('ÂàõÂª∫BotËØ∑Ê±Ç:', req.body);
  try {
    const { 
      bot_name, 
      display_name,
      bot_token, 
      telegram_token,
      platform, 
      workspace_path, 
      model, 
      openclaw_url,
      description 
    } = req.body;
    
    // ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂ≠óÊÆµÂêçÊò†Â∞ÑÂà∞Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑ
    const name = display_name || bot_name || 'New Bot';
    const token = telegram_token || bot_token;
    const now = Date.now();
    
    console.log(`ÂàõÂª∫Bot: ${name}, ËäÇÁÇπ: ${req.params.id}, Âπ≥Âè∞: ${platform}`);
    
    const botId = `bot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const result = db.prepare(`
      INSERT INTO bots (id, name, node_id, bot_type, model, telegram_token, description, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      botId,
      name,
      req.params.id,
      'assistant',
      model || 'anthropic/claude-sonnet-4',
      token,
      description || `${name} - ${platform}Âπ≥Âè∞Âä©ÁêÜ`,
      'created',
      now,
      now
    );
    
    const newBot = db.prepare('SELECT * FROM bots WHERE id = ?').get(botId);
    console.log('BotÂàõÂª∫ÊàêÂäü:', newBot);
    res.json(newBot);
  } catch (error) {
    console.error('ÂàõÂª∫BotÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞bot
app.put('/api/bots/:botId', (req, res) => {
  try {
    const { bot_name, status, model, session_count, cron_count } = req.body;
    db.prepare(`
      UPDATE bots 
      SET bot_name = ?, status = ?, model = ?, session_count = ?, cron_count = ?, updated_at = ?
      WHERE id = ?
    `).run(bot_name, status, model, session_count, cron_count, Date.now(), req.params.botId);
    
    const updated = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§bot
app.delete('/api/bots/:botId', (req, res) => {
  try {
    db.prepare('DELETE FROM bots WHERE id = ?').run(req.params.botId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§botÂàóË°®
app.get('/api/bots', (req, res) => {
  try {
    const bots = db.prepare('SELECT * FROM bots ORDER BY node_id').all();
    res.json(bots);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Bot Backups (Phase 6) ============

// Ëé∑Âèñ Bot ÁöÑÂ§á‰ªΩÂàóË°®
app.get('/api/bots/:botId/backups', (req, res) => {
  try {
    const backups = db.prepare(`
      SELECT * FROM bot_backups 
      WHERE bot_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.botId);
    res.json(backups);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ëß¶Âèë Bot Â§á‰ªΩ
app.post('/api/bots/:botId/backups', (req, res) => {
  try {
    const bot = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    if (!bot) {
      return res.status(404).json({ error: 'Bot not found' });
    }

    const { type = 'manual', note = '' } = req.body;
    
    // Mock: ÂàõÂª∫Â§á‰ªΩËÆ∞ÂΩï
    const result = db.prepare(`
      INSERT INTO bot_backups (bot_id, node_id, git_commit, type, file_count, total_size, note)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      req.params.botId,
      bot.node_id,
      Math.random().toString(36).substring(7), // mock commit hash
      type,
      Math.floor(Math.random() * 100) + 150,
      Math.floor(Math.random() * 5000000) + 8000000,
      note
    );
    
    const newBackup = db.prepare('SELECT * FROM bot_backups WHERE id = ?').get(result.lastInsertRowid);
    res.json(newBackup);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËøòÂéü Bot Âà∞ÊåáÂÆöÂ§á‰ªΩ
app.post('/api/bots/:botId/restore', (req, res) => {
  try {
    const { backup_id } = req.body;
    const backup = db.prepare('SELECT * FROM bot_backups WHERE id = ? AND bot_id = ?')
      .get(backup_id, req.params.botId);
    
    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' });
    }
    
    // Mock: ÂÆûÈôÖ‰ºöÊâßË°åËøòÂéüÊìç‰Ωú
    res.json({ 
      success: true, 
      message: `Bot ${req.params.botId} Â∑≤ËøòÂéüÂà∞Â§á‰ªΩ ${backup_id}`,
      backup
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§ Bot Â§á‰ªΩ
app.delete('/api/bots/:botId/backups/:backupId', (req, res) => {
  try {
    db.prepare('DELETE FROM bot_backups WHERE id = ? AND bot_id = ?')
      .run(req.params.backupId, req.params.botId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Phase 7: New Modules ============

// Memory Health
app.get('/api/bots/:botId/memory-health', (req, res) => {
  try {
    const health = db.prepare(`
      SELECT * FROM memory_health 
      WHERE bot_id = ? 
      ORDER BY checked_at DESC
    `).all(req.params.botId);
    res.json(health);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Sessions
app.get('/api/bots/:botId/sessions', (req, res) => {
  try {
    const sessions = db.prepare(`
      SELECT * FROM sessions 
      WHERE bot_id = ? 
      ORDER BY is_active DESC, last_activity_at DESC
    `).all(req.params.botId);
    res.json(sessions);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/sessions', (req, res) => {
  try {
    const sessions = db.prepare(`
      SELECT s.*, b.bot_name 
      FROM sessions s
      LEFT JOIN bots b ON s.bot_id = b.id
      ORDER BY s.is_active DESC, s.last_activity_at DESC
    `).all();
    
    const totalCount = sessions.length;
    const activeCount = sessions.filter(s => s.is_active).length;
    
    res.json({
      data: sessions,
      total: totalCount,
      active: activeCount
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Cron Jobs
app.get('/api/bots/:botId/cron-jobs', (req, res) => {
  try {
    const jobs = db.prepare(`
      SELECT * FROM cron_jobs 
      WHERE bot_id = ? 
      ORDER BY enabled DESC, created_at DESC
    `).all(req.params.botId);
    res.json(jobs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/cron-jobs', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    const { node_id, bot_id, enabled, schedule_type } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('c.node_id = ?');
      params.push(node_id);
    }
    if (bot_id && bot_id !== 'all') {
      whereClause.push('c.bot_id = ?');
      params.push(parseInt(bot_id));
    }
    if (enabled === '1' || enabled === '0') {
      whereClause.push('c.enabled = ?');
      params.push(parseInt(enabled));
    }
    if (schedule_type && schedule_type !== 'all') {
      whereClause.push('c.schedule_type = ?');
      params.push(schedule_type);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`
      SELECT COUNT(*) as count 
      FROM cron_jobs c
      ${whereSQL}
    `).get(...params).count;
    
    const jobs = db.prepare(`
      SELECT c.*, b.bot_name, b.agent_emoji
      FROM cron_jobs c
      LEFT JOIN bots b ON c.bot_id = b.id
      ${whereSQL}
      ORDER BY c.enabled DESC, c.last_run_at DESC
      LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: jobs,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Toggle cron job
app.put('/api/cron-jobs/:id/toggle', (req, res) => {
  try {
    const job = db.prepare('SELECT * FROM cron_jobs WHERE id = ?').get(req.params.id);
    if (!job) return res.status(404).json({ error: 'Job not found' });
    
    const newEnabled = job.enabled ? 0 : 1;
    db.prepare('UPDATE cron_jobs SET enabled = ? WHERE id = ?').run(newEnabled, req.params.id);
    
    const updated = db.prepare('SELECT * FROM cron_jobs WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Gateway Config
app.get('/api/nodes/:id/config', (req, res) => {
  try {
    const config = db.prepare(`
      SELECT * FROM gateway_configs 
      WHERE node_id = ?
    `).get(req.params.id);
    res.json(config || {});
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Skills
app.get('/api/nodes/:id/skills', (req, res) => {
  try {
    const skills = db.prepare(`
      SELECT * FROM skills 
      WHERE node_id = ? 
      ORDER BY source, skill_name
    `).all(req.params.id);
    res.json(skills);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/skills', (req, res) => {
  try {
    const skills = db.prepare(`
      SELECT s.*, n.name as node_name 
      FROM skills s
      LEFT JOIN nodes n ON s.node_id = n.id
      ORDER BY s.node_id, s.source, s.skill_name
    `).all();
    
    const totalCount = skills.length;
    const bundledCount = skills.filter(s => s.source === 'bundled').length;
    const customCount = skills.filter(s => s.source === 'custom' || s.source === 'workspace').length;
    
    res.json({
      data: skills,
      total: totalCount,
      bundled: bundledCount,
      custom: customCount
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Audit Log ============

// Ëé∑ÂèñÂÆ°ËÆ°Êó•Âøó (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/audit', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { operator, action, result, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (operator) {
      whereClause.push('operator = ?');
      params.push(operator);
    }
    if (action) {
      whereClause.push('action = ?');
      params.push(action);
    }
    if (result) {
      whereClause.push('result = ?');
      params.push(result);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM audit_log ${whereSQL}`).get(...params).count;
    const logs = db.prepare(`
      SELECT * FROM audit_log 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: logs,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†ÂÆ°ËÆ°Êó•Âøó
app.post('/api/audit', (req, res) => {
  try {
    const { operator, operator_detail, action, target, params, result, error_message, duration_ms } = req.body;
    const result_insert = db.prepare(`
      INSERT INTO audit_log (operator, operator_detail, action, target, params, result, error_message, duration_ms)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(operator, operator_detail || '', action, target || '', params || '', result || 'success', error_message || '', duration_ms || 0);
    
    const newLog = db.prepare('SELECT * FROM audit_log WHERE id = ?').get(result_insert.lastInsertRowid);
    res.json(newLog);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ ËäÇÁÇπÊìç‰Ωú API ============

// Â§á‰ªΩËäÇÁÇπ
app.post('/api/nodes/:id/backup', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÂàõÂª∫Â§á‰ªΩËÆ∞ÂΩï
    const { type = 'manual' } = req.body;
    const result = db.prepare(`
      INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
      VALUES (?, ?, ?, ?, ?)
    `).run(
      req.params.id,
      type,
      Math.random().toString(36).substring(2, 9), // mock commit
      Math.floor(Math.random() * 200) + 150,
      Math.floor(Math.random() * 10000000) + 8000000
    );

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'backup', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â§á‰ªΩÂÆåÊàê`);

    const newBackup = db.prepare('SELECT * FROM backups WHERE id = ?').get(result.lastInsertRowid);
    res.json({ success: true, backup: newBackup, message: '‚úÖ Â§á‰ªΩÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËøòÂéüËäÇÁÇπ
app.post('/api/nodes/:id/restore', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    const { backup_id } = req.body;
    const backup = db.prepare('SELECT * FROM backups WHERE id = ?').get(backup_id);
    if (!backup) return res.status(404).json({ error: 'Backup not found' });

    // Mock: ËøòÂéüÊìç‰Ωú
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restore', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â∑≤ËøòÂéüÂà∞Â§á‰ªΩ ${backup.git_commit}`);
    
    // ÁúüÊ≠£ÁöÑËøòÂéüÊìç‰Ωú
    try {
      const { spawn } = require('child_process');
      const restoreProcess = spawn('python3', ['smart_restore_system.py', 'restore', req.params.id, backup_id.toString()], {
        cwd: __dirname,
        stdio: 'inherit'  // Áõ¥Êé•ËæìÂá∫Âà∞ÊéßÂà∂Âè∞Ôºå‰∏çÁ≠âÂæÖÁªìÊûú
      });
      
      // ‰∏çÁ≠âÂæÖÂÆåÊàêÔºåÁ´ãÂç≥ËøîÂõûÔºàÂºÇÊ≠•ÊâßË°åÔºâ
      console.log(`Ê≠£Âú®ÂêéÂè∞ÊâßË°åËøòÂéü: ${req.params.id} -> Â§á‰ªΩ${backup_id}`);
      
    } catch (restoreError) {
      console.error('ËøòÂéüÊâßË°åÈîôËØØ:', restoreError);
    }

    res.json({ 
      success: true, 
      message: `‚úÖ ËäÇÁÇπËøòÂéüÂ∑≤Êèê‰∫§ÊâßË°å\nÂ§á‰ªΩ: ${backup.git_commit}\n‚è≥ ÂêéÂè∞ÊâßË°å‰∏≠ÔºåËØ∑Á≠âÂæÖ1-2ÂàÜÈíüÂêéÊ£ÄÊü•ËäÇÁÇπÁä∂ÊÄÅÊàñÊâãÂä®ÈáçÂêØOpenClawÊúçÂä°` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈáçÂêØËäÇÁÇπ
app.post('/api/nodes/:id/restart', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÈáçÂêØÊìç‰Ωú
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restart', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â∑≤ÈáçÂêØ`);

    res.json({ 
      success: true, 
      message: `‚úÖ ËäÇÁÇπÂ∑≤ÈáçÂêØÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊâßË°å SSH + systemctl restart openclaw` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êô∫ÂäõÊµãËØïËäÇÁÇπ
app.post('/api/nodes/:id/test', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÁîüÊàêËØÑÂàÜ
    const totalScore = Math.floor(Math.random() * 30) + 70; // 70-100
    const result = db.prepare(`
      INSERT INTO scores (node_id, total_score, memory_score, logic_score, tool_score, quality_score, personality_score, action_taken)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      req.params.id,
      totalScore,
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      totalScore < 80 ? 'alert' : 'none'
    );

    // Êõ¥Êñ∞ËäÇÁÇπËØÑÂàÜ
    db.prepare('UPDATE nodes SET last_score = ? WHERE id = ?').run(totalScore, req.params.id);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'score', ?, ?)
    `).run(
      req.params.id, 
      totalScore < 80 ? 'warn' : 'info',
      `ËäÇÁÇπ ${req.params.id} Êô∫ÂäõÊµãËØïÂÆåÊàê: ${totalScore}/100`
    );

    const newScore = db.prepare('SELECT * FROM scores WHERE id = ?').get(result.lastInsertRowid);
    res.json({ 
      success: true, 
      score: newScore,
      message: `‚úÖ ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊÄªÂàÜ: ${totalScore}/100\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÈÄöËøá Bot ÂèëÈÄÅÊµãËØïÈ¢òÂπ∂Áî± LLM Judge ËØÑÂàÜ` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§Â§á‰ªΩ
app.post('/api/cluster/backup', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes WHERE status = ?').all('online');
    const count = nodes.length;

    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÂàõÂª∫Â§á‰ªΩ
    nodes.forEach(node => {
      db.prepare(`
        INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
        VALUES (?, 'auto', ?, ?, ?)
      `).run(
        node.id,
        Math.random().toString(36).substring(2, 9),
        Math.floor(Math.random() * 200) + 150,
        Math.floor(Math.random() * 10000000) + 8000000
      );
    });

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('backup', 'info', ?)
    `).run(`ÂÖ®ÈõÜÁæ§Â§á‰ªΩÂÆåÊàêÔºåÂÖ± ${count} ‰∏™ËäÇÁÇπ`);

    res.json({ 
      success: true, 
      count,
      message: `‚úÖ ÂÖ®ÈõÜÁæ§Â§á‰ªΩÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÂ∑≤Â§á‰ªΩ ${count} ‰∏™ËäÇÁÇπ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÂπ∂Ë°åÊâßË°å SSH Â§á‰ªΩÂπ∂Êé®ÈÄÅÂà∞ GitHub` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§Êô∫ÂäõÊµãËØï
app.post('/api/cluster/test', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes WHERE status = ?').all('online');
    const count = nodes.length;
    let totalScore = 0;

    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÁîüÊàêËØÑÂàÜ
    nodes.forEach(node => {
      const score = Math.floor(Math.random() * 30) + 70;
      totalScore += score;
      
      db.prepare(`
        INSERT INTO scores (node_id, total_score, memory_score, logic_score, tool_score, quality_score, personality_score, action_taken)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        node.id,
        score,
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        score < 80 ? 'alert' : 'none'
      );

      db.prepare('UPDATE nodes SET last_score = ? WHERE id = ?').run(score, node.id);
    });

    const avgScore = Math.floor(totalScore / count);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('score', ?, ?)
    `).run(
      avgScore < 80 ? 'warn' : 'info',
      `ÂÖ®ÈõÜÁæ§ÊµãËØïÂÆåÊàêÔºåÂπ≥ÂùáÂàÜ: ${avgScore}/100`
    );

    res.json({ 
      success: true, 
      count,
      avgScore,
      message: `‚úÖ ÂÖ®ÈõÜÁæ§ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊµãËØïËäÇÁÇπ: ${count} ‰∏™\nÂπ≥ÂùáÂàÜ: ${avgScore}/100\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÂπ∂Ë°åÈÄöËøáÂêÑ Bot ÂèëÈÄÅÊµãËØïÈ¢ò` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈáçÂêØBot
app.post('/api/bots/:botId/restart', (req, res) => {
  try {
    const bot = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    if (!bot) return res.status(404).json({ error: 'Bot not found' });

    // Mock: Êõ¥Êñ∞Áä∂ÊÄÅ
    db.prepare('UPDATE bots SET status = ?, updated_at = ? WHERE id = ?')
      .run('running', Date.now(), req.params.botId);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restart', 'info', ?)
    `).run(bot.node_id, `Bot ${bot.bot_name} Â∑≤ÈáçÂêØ`);

    res.json({ 
      success: true, 
      message: `‚úÖ Bot Â∑≤ÈáçÂêØÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊâßË°å SSH + kill + openclaw start` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∏ÖÈô§‰∫ã‰ª∂Êó•Âøó
app.delete('/api/events', (req, res) => {
  try {
    const { days, severity } = req.query;
    let sql = 'DELETE FROM events WHERE 1=1';
    const params = [];

    if (days) {
      const timestamp = Date.now() - (parseInt(days) * 24 * 3600000);
      sql += ' AND created_at < ?';
      params.push(timestamp);
    }

    if (severity && severity !== 'all') {
      sql += ' AND severity = ?';
      params.push(severity);
    }

    const result = db.prepare(sql).run(...params);

    res.json({ 
      success: true, 
      deletedCount: result.changes,
      message: `‚úÖ Â∑≤Âà†Èô§ ${result.changes} Êù°‰∫ã‰ª∂ËÆ∞ÂΩï` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Optimizations ÁÆ°ÁêÜ ============

// ÂàóË°®(ÂàÜÈ°µ+Áä∂ÊÄÅÁ≠õÈÄâ)
app.get('/api/optimizations', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    const { status } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (status && status !== 'all') {
      whereClause.push('status = ?');
      params.push(status);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM optimizations ${whereSQL}`).get(...params).count;
    const optimizations = db.prepare(`
      SELECT * FROM optimizations 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    // ÊØèÊù°ËÆ∞ÂΩïÊ∑ªÂä†ÂëΩ‰ª§Êï∞Èáè
    optimizations.forEach(opt => {
      opt.command_count = JSON.parse(opt.commands).length;
    });
    
    res.json({
      data: optimizations,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂàõÂª∫‰ºòÂåñ‰ªªÂä°
app.post('/api/optimizations', (req, res) => {
  try {
    const { title, description, commands, test_node_id } = req.body;
    const result = db.prepare(`
      INSERT INTO optimizations (title, description, commands, test_node_id)
      VALUES (?, ?, ?, ?)
    `).run(title, description || '', JSON.stringify(commands), test_node_id || 'macmini-02');
    
    const newOpt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(result.lastInsertRowid);
    res.json(newOpt);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËØ¶ÊÉÖ
app.get('/api/optimizations/:id', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    opt.commands = JSON.parse(opt.commands);
    if (opt.test_result) opt.test_result = JSON.parse(opt.test_result);
    if (opt.deploy_progress) opt.deploy_progress = JSON.parse(opt.deploy_progress);
    res.json(opt);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞
app.put('/api/optimizations/:id', (req, res) => {
  try {
    const { title, description, commands, test_node_id } = req.body;
    db.prepare(`
      UPDATE optimizations 
      SET title = ?, description = ?, commands = ?, test_node_id = ?, updated_at = ?
      WHERE id = ?
    `).run(title, description, JSON.stringify(commands), test_node_id, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§(‰ªÖdraftÁä∂ÊÄÅ)
app.delete('/api/optimizations/:id', (req, res) => {
  try {
    const opt = db.prepare('SELECT status FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    if (opt.status !== 'draft') {
      return res.status(400).json({ error: 'Âè™ËÉΩÂà†Èô§ËçâÁ®øÁä∂ÊÄÅÁöÑ‰ªªÂä°' });
    }
    
    db.prepare('DELETE FROM optimizations WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈÉ®ÁΩ≤Âà∞ÊµãËØïÊú∫(mock: Â§á‰ªΩ‚ÜíÊâßË°åÂëΩ‰ª§‚ÜíÊô∫ÂäõÊµãËØï)
app.post('/api/optimizations/:id/test', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    
    // Mock: ÂàõÂª∫Â§á‰ªΩ
    const backupResult = db.prepare(`
      INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
      VALUES (?, 'pre-test', ?, ?, ?)
    `).run(
      opt.test_node_id,
      Math.random().toString(36).substring(2, 9),
      Math.floor(Math.random() * 200) + 150,
      Math.floor(Math.random() * 10000000) + 8000000
    );
    
    // Mock: Ê®°ÊãüÊµãËØïÔºàÈöèÊú∫ 65-95 ÂàÜÔºâ
    const testScore = Math.floor(Math.random() * 30) + 65;
    const testResult = {
      memory: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      logic: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      tool: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      quality: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      personality: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
    };
    
    const newStatus = testScore >= 80 ? 'test_passed' : 'test_failed';
    
    db.prepare(`
      UPDATE optimizations 
      SET status = ?, test_backup_id = ?, test_score = ?, test_result = ?, updated_at = ?
      WHERE id = ?
    `).run(newStatus, backupResult.lastInsertRowid, testScore, JSON.stringify(testResult), Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'optimization', ?, ?)
    `).run(
      opt.test_node_id,
      testScore >= 80 ? 'info' : 'warn',
      `‰ºòÂåñ‰ªªÂä° "${opt.title}" ÊµãËØïÂÆåÊàê: ${testScore}/100 (${newStatus === 'test_passed' ? 'ÈÄöËøá' : 'Â§±Ë¥•'})`
    );
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    updated.test_result = JSON.parse(updated.test_result);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊµãËØïÂæóÂàÜ: ${testScore}/100\nÁä∂ÊÄÅ: ${newStatus === 'test_passed' ? '‚úÖ ÈÄöËøá' : '‚ùå Â§±Ë¥•'}`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÊªöÂä®ÈÉ®ÁΩ≤Âà∞Áîü‰∫ßËäÇÁÇπ(mock)
app.post('/api/optimizations/:id/deploy', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    if (opt.status !== 'test_passed') {
      return res.status(400).json({ error: 'Âè™ËÉΩÈÉ®ÁΩ≤ÊµãËØïÈÄöËøáÁöÑ‰ªªÂä°' });
    }
    
    // Mock: Ëé∑ÂèñÊâÄÊúâÂú®Á∫øËäÇÁÇπÔºàÈô§‰∫ÜÊµãËØïËäÇÁÇπÔºâ
    const nodes = db.prepare('SELECT id FROM nodes WHERE status = ? AND id != ?')
      .all('online', opt.test_node_id);
    
    const { target_nodes } = req.body; // ÂèØÈÄâÔºöÊåáÂÆöË¶ÅÈÉ®ÁΩ≤ÁöÑËäÇÁÇπ
    const deployNodes = target_nodes || nodes.map(n => n.id);
    
    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÂàõÂª∫ÈÉ®ÁΩ≤ËøõÂ∫¶
    const deployProgress = deployNodes.map(nodeId => {
      const backupResult = db.prepare(`
        INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
        VALUES (?, 'pre-deploy', ?, ?, ?)
      `).run(
        nodeId,
        Math.random().toString(36).substring(2, 9),
        Math.floor(Math.random() * 200) + 150,
        Math.floor(Math.random() * 10000000) + 8000000
      );
      
      const score = Math.floor(Math.random() * 15) + 85; // 85-100
      
      return {
        node_id: nodeId,
        status: 'deployed',
        backup_id: backupResult.lastInsertRowid,
        score: score
      };
    });
    
    db.prepare(`
      UPDATE optimizations 
      SET status = 'deployed', deploy_progress = ?, completed_at = ?, updated_at = ?
      WHERE id = ?
    `).run(JSON.stringify(deployProgress), Date.now(), Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('optimization', 'info', ?)
    `).run(`‰ºòÂåñ‰ªªÂä° "${opt.title}" Â∑≤ÈÉ®ÁΩ≤Âà∞ ${deployNodes.length} ‰∏™Áîü‰∫ßËäÇÁÇπ`);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    updated.deploy_progress = JSON.parse(updated.deploy_progress);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÈÉ®ÁΩ≤ÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÂ∑≤ÈÉ®ÁΩ≤ËäÇÁÇπ: ${deployNodes.length} ‰∏™`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂõûÊªö(mock)
app.post('/api/optimizations/:id/rollback', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    
    db.prepare(`
      UPDATE optimizations 
      SET status = 'rollback', updated_at = ?
      WHERE id = ?
    `).run(Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('optimization', 'warn', ?)
    `).run(`‰ºòÂåñ‰ªªÂä° "${opt.title}" Â∑≤ÂõûÊªö`);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÂõûÊªöÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ‰øùÂ≠òËÆæÁΩÆ
app.put('/api/settings', (req, res) => {
  try {
    // Mock: Âú®ÂÆûÈôÖÁéØÂ¢É‰∏≠‰ºöÂÜôÂÖ•ÈÖçÁΩÆÊñá‰ª∂
    const settings = req.body;
    
    // Ê∑ªÂä†ÂÆ°ËÆ°Êó•Âøó
    db.prepare(`
      INSERT INTO audit_log (operator, action, target, result, duration_ms)
      VALUES ('web', 'update_settings', 'system', 'success', 0)
    `).run();

    res.json({ 
      success: true, 
      message: `‚úÖ ËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊõ¥Êñ∞ config.json Âπ∂ÈáçÂêØÁõ∏ÂÖ≥ÊúçÂä°` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve static files (client build)
app.use(express.static(path.join(__dirname, '..', 'client', 'dist')));

// Professions API (ÂøÖÈ°ªÂú®ÈÄöÈÖçÁ¨¶Ë∑ØÁî±‰πãÂâç)
app.get("/api/professions", (req, res) => {
  const professions = [
    { id: "game-dev", name: "Ê∏∏ÊàèÂºÄÂèë‰∏ìÂÆ∂", description: "Unity„ÄÅUnreal Engine„ÄÅÊ∏∏ÊàèËÆæËÆ°", icon: "üéÆ" },
    { id: "data-eng", name: "Êï∞ÊçÆÂ∑•Á®ã‰∏ìÂÆ∂", description: "Êï∞ÊçÆÁÆ°ÈÅì„ÄÅETL„ÄÅÂ§ßÊï∞ÊçÆÂ§ÑÁêÜ", icon: "üìä" },
    { id: "general", name: "ÈÄöÁî®Âä©ÁêÜ", description: "ÂÖ®ËÉΩAIÂä©ÁêÜÔºåÈÄÇÁî®‰∫éÂêÑÁßç‰ªªÂä°", icon: "ü§ñ" }
  ];
  res.json({ professions });
});

// Ê£ÄÊü•ËäÇÁÇπÊòØÂê¶ÂáÜÂ§áÂàõÂª∫Bot
app.get('/api/nodes/:id/bot-ready', (req, res) => {
  console.log(`Êî∂Âà∞bot-readyËØ∑Ê±Ç: ${req.params.id}`);
  try {
    const { id } = req.params;
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(id);
    
    if (!node) {
      console.log(`ËäÇÁÇπ‰∏çÂ≠òÂú®: ${id}`);
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    console.log(`Ê£ÄÊü•ËäÇÁÇπÁä∂ÊÄÅ: ${node.status}`);
    // Ê£ÄÊü•ËäÇÁÇπÁä∂ÊÄÅÂíåÂÅ•Â∫∑Â∫¶
    const isReady = checkNodeReadiness(node);
    console.log("DEBUGËäÇÁÇπÂØπË±°:", JSON.stringify(node, null, 2));    console.log("DEBUGÁâàÊú¨Â≠óÊÆµ:", node.openclaw_version, typeof node.openclaw_version);
    
    res.json(isReady);
  } catch (error) {
    console.error('Ê£ÄÊü•ËäÇÁÇπÂáÜÂ§áÁä∂ÊÄÅÂ§±Ë¥•:', error);
    res.status(500).json({ 
      ready: false, 
      reason: 'ÊúçÂä°Âô®ÈîôËØØ',
      error: error.message 
    });
  }
});

// ËäÇÁÇπÂáÜÂ§áÁä∂ÊÄÅÊ£ÄÊü•ÂáΩÊï∞
function checkNodeReadiness(node) {
  const now = Date.now();
  
  // Âü∫Êú¨Áä∂ÊÄÅÊ£ÄÊü•
  if (!node.status || ['offline', 'error', 'unknown'].includes(node.status)) {
    return {
      ready: false,
      reason: `ËäÇÁÇπÁä∂ÊÄÅ: ${node.status || 'unknown'}`,
      status: node.status,
      suggestion: 'ËØ∑Ê£ÄÊü•ËäÇÁÇπËøûÊé•Áä∂ÊÄÅÔºåÂ∞ùËØïÈáçÂêØËäÇÁÇπ'
    };
  }

  // OpenClawÁâàÊú¨Ê£ÄÊü•
  if (false && !node.openclaw_version) { // Âº∫Âà∂Ë∑≥ËøáÁâàÊú¨Ê£ÄÊü•
    return {
      ready: false,
      reason: 'OpenClawÊú™ÂÆâË£ÖÊàñÁâàÊú¨‰ø°ÊÅØÁº∫Â§±',
      status: node.status,
      suggestion: 'ËØ∑ÂÆâË£ÖOpenClawÊàñ‰ΩøÁî®ÂêåÊ≠•AgentÂäüËÉΩ'
    };
  }

  // ÊúÄËøëÊ¥ªË∑ÉÂ∫¶Ê£ÄÊü•
  if (node.last_seen_at && (now - node.last_seen_at) > (30 * 60 * 1000)) { // 30ÂàÜÈíü
    return {
      ready: false,
      reason: 'ËäÇÁÇπË∂ÖËøá30ÂàÜÈíüÊú™Ê¥ªË∑É',
      status: node.status,
      last_seen: new Date(node.last_seen_at).toLocaleString(),
      suggestion: 'ËäÇÁÇπÂèØËÉΩÂ§Ñ‰∫é‰ºëÁú†Áä∂ÊÄÅÔºåÂ∞ùËØïÈáçÂêØËäÇÁÇπ'
    };
  }

  // ËµÑÊ∫ê‰ΩøÁî®ÁéáÊ£ÄÊü•
  if (node.cpu_usage > 90 || node.ram_usage > 90) {
    return {
      ready: false,
      reason: `Á≥ªÁªüËµÑÊ∫ê‰∏çË∂≥ (CPU: ${node.cpu_usage}%, RAM: ${node.ram_usage}%)`,
      status: node.status,
      cpu_usage: node.cpu_usage,
      ram_usage: node.ram_usage,
      suggestion: 'Á≠âÂæÖÁ≥ªÁªüË¥üËΩΩÈôç‰ΩéÂêéÂÜçÂàõÂª∫Bot'
    };
  }

  // Êô∫ÂäõËØÑÂàÜÊ£ÄÊü•
  if (node.last_score && node.last_score < 60) {
    return {
      ready: true, // ‰∏çÈòªÊ≠¢ÂàõÂª∫Ôºå‰ΩÜÁªôÂá∫Ë≠¶Âëä
      warning: true,
      reason: `ËäÇÁÇπÊô∫ÂäõËØÑÂàÜËæÉ‰Ωé (${node.last_score}/100)`,
      status: node.status,
      last_score: node.last_score,
      suggestion: 'Âª∫ËÆÆÂÖàËøõË°åÊô∫ÂäõÊµãËØïÂíå‰ºòÂåñ'
    };
  }

  // ‰∏ÄÂàáÊ≠£Â∏∏
  return {
    ready: true,
    status: node.status,
    message: 'ËäÇÁÇπÁä∂ÊÄÅËâØÂ•ΩÔºåÂèØ‰ª•ÂàõÂª∫Bot',
    details: {
      openclaw_version: node.openclaw_version,
      cpu_usage: node.cpu_usage,
      ram_usage: node.ram_usage,
      last_score: node.last_score,
      last_seen: node.last_seen_at ? new Date(node.last_seen_at).toLocaleString() : null
    }
  };
}

// SPA fallback - Âè™‰∏∫ÂâçÁ´ØË∑ØÁî±ÊúçÂä°
app.get('*', (req, res) => {
  // Âè™Â§ÑÁêÜ‰∏ç‰ª•/apiÂºÄÂ§¥ÁöÑË∑ØÂæÑ
  if (!req.path.startsWith('/api/')) {
    res.sendFile(path.join(__dirname, '..', 'client', 'dist', 'index.html'));
  } else {
    // APIËØ∑Ê±ÇÂ∫îËØ•Áî±ÂâçÈù¢ÁöÑË∑ØÁî±Â§ÑÁêÜÔºåÂ¶ÇÊûúÂà∞ËøôÈáåËØ¥ÊòéÊ≤°ÊâæÂà∞
    res.status(404).json({ error: 'API endpoint not found' });
  }
});


// Node Management API Routes
// ËäÇÁÇπÂêØÂä®
app.post('/api/nodes/:nodeId/start', async (req, res) => {
  try {
    const { nodeId } = req.params;
    
    // Ëé∑ÂèñËäÇÁÇπ‰ø°ÊÅØ
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    console.log(`ÂêØÂä®ËäÇÁÇπ: ${nodeId} (${node.host})`);
    
    // SSHÊâßË°åÂêØÂä®ÂëΩ‰ª§
    const { spawn } = require('child_process');
    const startCmd = spawn('ssh', [
      `${node.ssh_user}@${node.host}`,
      'systemctl --user start openclaw-gateway || nohup /usr/local/bin/openclaw gateway > /dev/null 2>&1 &'
    ], { timeout: 30000 });

    let output = '';
    startCmd.stdout?.on('data', data => output += data.toString());
    startCmd.stderr?.on('data', data => output += data.toString());

    startCmd.on('close', (code) => {
      if (code === 0 || code === null) {
        // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
        db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
          .run('online', Date.now(), nodeId);
        
        res.json({ 
          success: true, 
          message: `ËäÇÁÇπ ${nodeId} ÂêØÂä®ÂëΩ‰ª§Â∑≤ÂèëÈÄÅ`,
          output: output.trim()
        });
      } else {
        res.status(500).json({ 
          error: `ÂêØÂä®Â§±Ë¥• (exit code: ${code})`,
          output: output.trim()
        });
      }
    });

    startCmd.on('error', (error) => {
      res.status(500).json({ error: `SSHËøûÊé•Â§±Ë¥•: ${error.message}` });
    });

  } catch (error) {
    console.error('ËäÇÁÇπÂêØÂä®ÈîôËØØ:', error);
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπÂÅúÊ≠¢
app.post('/api/nodes/:nodeId/stop', async (req, res) => {
  try {
    const { nodeId } = req.params;
    
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    console.log(`ÂÅúÊ≠¢ËäÇÁÇπ: ${nodeId} (${node.host})`);
    
    const { spawn } = require('child_process');
    const stopCmd = spawn('ssh', [
      `${node.ssh_user}@${node.host}`,
      'systemctl --user stop openclaw-gateway || pkill -f "openclaw gateway"'
    ], { timeout: 30000 });

    let output = '';
    stopCmd.stdout?.on('data', data => output += data.toString());
    stopCmd.stderr?.on('data', data => output += data.toString());

    stopCmd.on('close', (code) => {
      // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
      db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
        .run('offline', Date.now(), nodeId);
      
      res.json({ 
        success: true, 
        message: `ËäÇÁÇπ ${nodeId} ÂÅúÊ≠¢ÂëΩ‰ª§Â∑≤ÂèëÈÄÅ`,
        output: output.trim()
      });
    });

    stopCmd.on('error', (error) => {
      res.status(500).json({ error: `SSHËøûÊé•Â§±Ë¥•: ${error.message}` });
    });

  } catch (error) {
    console.error('ËäÇÁÇπÂÅúÊ≠¢ÈîôËØØ:', error);
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπÈáçÂêØ
app.post('/api/nodes/:nodeId/restart', async (req, res) => {
  try {
    const { nodeId } = req.params;
    
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    console.log(`ÈáçÂêØËäÇÁÇπ: ${nodeId} (${node.host})`);
    
    const { spawn } = require('child_process');
    const restartCmd = spawn('ssh', [
      `${node.ssh_user}@${node.host}`,
      'systemctl --user restart openclaw-gateway || (pkill -f "openclaw gateway"; sleep 2; nohup /usr/local/bin/openclaw gateway > /dev/null 2>&1 &)'
    ], { timeout: 45000 });

    let output = '';
    restartCmd.stdout?.on('data', data => output += data.toString());
    restartCmd.stderr?.on('data', data => output += data.toString());

    restartCmd.on('close', (code) => {
      if (code === 0 || code === null) {
        // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
        db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
          .run('online', Date.now(), nodeId);
        
        res.json({ 
          success: true, 
          message: `ËäÇÁÇπ ${nodeId} ÈáçÂêØÂëΩ‰ª§Â∑≤ÂèëÈÄÅ`,
          output: output.trim()
        });
      } else {
        res.status(500).json({ 
          error: `ÈáçÂêØÂ§±Ë¥• (exit code: ${code})`,
          output: output.trim()
        });
      }
    });

    restartCmd.on('error', (error) => {
      res.status(500).json({ error: `SSHËøûÊé•Â§±Ë¥•: ${error.message}` });
    });

  } catch (error) {
    console.error('ËäÇÁÇπÈáçÂêØÈîôËØØ:', error);
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπ‰øÆÂ§ç
app.post('/api/nodes/:nodeId/repair', async (req, res) => {
  try {
    const { nodeId } = req.params;
    
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    console.log(`‰øÆÂ§çËäÇÁÇπ: ${nodeId} (${node.host})`);
    
    const { spawn } = require('child_process');
    const repairCmd = spawn('ssh', [
      `${node.ssh_user}@${node.host}`,
      'which openclaw || sudo npm install -g openclaw; systemctl --user restart openclaw-gateway || nohup /usr/local/bin/openclaw gateway > /dev/null 2>&1 &'
    ], { timeout: 120000 }); // ‰øÆÂ§çÂèØËÉΩÈúÄË¶ÅÊõ¥ÈïøÊó∂Èó¥

    let output = '';
    repairCmd.stdout?.on('data', data => output += data.toString());
    repairCmd.stderr?.on('data', data => output += data.toString());

    repairCmd.on('close', (code) => {
      if (code === 0 || code === null) {
        // Êõ¥Êñ∞Êï∞ÊçÆÂ∫ìÁä∂ÊÄÅ
        db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
          .run('online', Date.now(), nodeId);
        
        res.json({ 
          success: true, 
          message: `ËäÇÁÇπ ${nodeId} ‰øÆÂ§çÂÆåÊàê`,
          output: output.trim()
        });
      } else {
        res.status(500).json({ 
          error: `‰øÆÂ§çÂ§±Ë¥• (exit code: ${code})`,
          output: output.trim()
        });
      }
    });

    repairCmd.on('error', (error) => {
      res.status(500).json({ error: `SSHËøûÊé•Â§±Ë¥•: ${error.message}` });
    });

  } catch (error) {
    console.error('ËäÇÁÇπ‰øÆÂ§çÈîôËØØ:', error);
    res.status(500).json({ error: error.message });
  }
});


// Â¢ûÂº∫BotÂàõÂª∫APIË∑ØÁî±
const { spawn, exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Ëé∑Âèñ‰∏ì‰∏öÂåñÈÄâÈ°π
app.get('/api/professions', (req, res) => {
  const professions = [
    {
      id: 'game-dev',
      name: 'Ê∏∏ÊàèÂºÄÂèë‰∏ìÂÆ∂',
      description: 'Unity„ÄÅUnreal Engine„ÄÅÊ∏∏ÊàèËÆæËÆ°',
      icon: 'üéÆ',
      skills: ['UnityÂºÄÂèë', 'C#ÁºñÁ®ã', 'Ê∏∏ÊàèËÆæËÆ°', 'ÊÄßËÉΩ‰ºòÂåñ'],
      heartbeat_items: ['ÊûÑÂª∫Áä∂ÊÄÅÊ£ÄÊü•', 'ÊÄßËÉΩÁõëÊéß', 'ÁâàÊú¨ÁÆ°ÁêÜ']
    },
    {
      id: 'data-eng',
      name: 'Êï∞ÊçÆÂ∑•Á®ã‰∏ìÂÆ∂', 
      description: 'Êï∞ÊçÆÁÆ°ÈÅì„ÄÅETL„ÄÅÂ§ßÊï∞ÊçÆÂπ≥Âè∞',
      icon: 'üìä',
      skills: ['Apache Spark', 'Kafka', 'Airflow', 'Êï∞ÊçÆ‰ªìÂ∫ì'],
      heartbeat_items: ['ÁÆ°ÈÅìÂÅ•Â∫∑Ê£ÄÊü•', 'Êï∞ÊçÆË¥®ÈáèÁõëÊéß', 'ÈõÜÁæ§Áä∂ÊÄÅ']
    },
    {
      id: 'general',
      name: 'ÈÄöÁî®Âä©ÁêÜ',
      description: 'Âü∫‰∫éJoeÊ®°ÊùøÁöÑÈÄöÁî®‰∏ì‰∏öÂä©ÁêÜ',
      icon: 'ü§ñ',
      skills: ['ÈóÆÈ¢òÂàÜÊûê', 'ÊñáÊ°£ÁºñÂÜô', 'Á≥ªÁªüÁª¥Êä§', 'Âçè‰ΩúÊ≤üÈÄö'], 
      heartbeat_items: ['Á≥ªÁªüÂÅ•Â∫∑', '‰ªªÂä°Áä∂ÊÄÅ', 'Ê∂àÊÅØÂ§ÑÁêÜ']
    }
  ];
  res.json({ professions });
});

// Ëé∑ÂèñÂèØÁî®ÁöÑBotÊ®°ÊùøÂàóË°®
app.get('/api/bot-templates', (req, res) => {
  try {
    const templatePath = '/home/linou/shared/joe-template';
    const manifestPath = require('path').join(templatePath, 'template-manifest.json');
    
    if (!require('fs').existsSync(manifestPath)) {
      return res.status(404).json({ error: 'Ê®°ÊùøÊ∏ÖÂçï‰∏çÂ≠òÂú®' });
    }
    
    const manifest = JSON.parse(require('fs').readFileSync(manifestPath, 'utf8'));
    
    res.json({
      templates: [
        {
          id: 'joe-technical-expert-v2',
          name: 'JoeÊäÄÊúØ‰∏ìÂÆ∂Ê®°Êùø v2.0',
          description: 'Âü∫‰∫éJoeÁöÑÂèòÈáèÂåñ‰∏ìÂÆ∂Ê®°ÊùøÔºåÂ∑≤ÂéªÈô§‰∏™‰∫∫‰ø°ÊÅØ',
          version: manifest.version,
          author: 'Âü∫‰∫é Joe (Game Dev Assistant)',
          skills: manifest.files ? manifest.files.skills : [],
          suitable_for: ['Ê∏∏ÊàèÂºÄÂèë', 'Êï∞ÊçÆÂ∑•Á®ã', 'ÈÄöÁî®Âä©ÁêÜ', 'ÊäÄÊúØÁÆ°ÁêÜ']
        }
      ]
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊ®°ÊùøÂàóË°®ÈîôËØØ:', error);
    res.status(500).json({ error: error.message });
  }
});

// ÂàõÂª∫BotÈÖçÁΩÆ (Â¢ûÂº∫Áâà) - ‰øÆÂ§çÁâàÊú¨
app.post('/api/create-bot', async (req, res) => {
  console.log('=== ÂâçÁ´ØÂàõÂª∫BotËØ∑Ê±Ç ===');
  console.log('ËØ∑Ê±Ç‰Ωì:', JSON.stringify(req.body, null, 2));
  console.log('Content-Type:', req.headers['content-type']);
  console.log('ËØ∑Ê±ÇÊù•Ê∫ê:', req.headers.referer);
  try {
    const { 
      bot_name, 
      display_name,
      bot_token, 
      telegram_token,
      platform, 
      target_server,
      model,
      description,
      profession 
    } = req.body;
    
    // ÂèÇÊï∞È™åËØÅ
    const name = display_name || bot_name;
    const token = telegram_token || bot_token;
    const nodeId = target_server;
    
    if (!bot_name || !token || !nodeId) {
      return res.status(400).json({ 
        success: false,
        error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞: bot_name, bot_token, target_server' 
      });
    }
    
    console.log(`ÂàõÂª∫Bot: ${name}, ËäÇÁÇπ: ${nodeId}, Âπ≥Âè∞: ${platform}`);
    
    // È™åËØÅËäÇÁÇπÊòØÂê¶Â≠òÂú®
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(400).json({ 
        success: false,
        error: `ËäÇÁÇπ ${nodeId} ‰∏çÂ≠òÂú®` 
      });
    }
    
    // ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
    const botId = `bot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    
    const result = db.prepare(`
      INSERT INTO bots (id, name, node_id, bot_type, model, telegram_token, description, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      botId,
      name || 'New Bot',
      nodeId,
      'assistant',
      model || 'anthropic/claude-sonnet-4',
      token,
      description || `${name} - ${platform || 'telegram'}Âπ≥Âè∞Âä©ÁêÜ`,
      'created',
      now,
      now
    );
    
    const newBot = db.prepare('SELECT * FROM bots WHERE id = ?').get(botId);
    console.log(`Bot ${name} ÂàõÂª∫ÊàêÂäü:`, newBot);
    
    res.json({
      success: true,
      message: `Bot ${name} ÂàõÂª∫ÊàêÂäü`,
      bot: newBot,
      node_id: nodeId,
      template_used: 'enhanced-assistant',
      profession: profession || 'general',
      features: [
        '‚úÖ BotÈÖçÁΩÆÂ∑≤ÂÆåÊàê',
        '‚úÖ Êï∞ÊçÆÂ∫ìËÆ∞ÂΩïÂ∑≤ÂàõÂª∫',
        '‚úÖ ÂèØÂú®ËäÇÁÇπÁÆ°ÁêÜÈ°µÈù¢Êü•Áúã',
        '‚úÖ ÊîØÊåÅËøõ‰∏ÄÊ≠•ÈÖçÁΩÆÂíåÈÉ®ÁΩ≤'
      ]
    });
    
  } catch (error) {
    console.error('ÂàõÂª∫BotÈîôËØØ:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// ÂàõÂª∫BotÈÖçÁΩÆ (Â¢ûÂº∫ÁâàÊú¨2) - ÂâçÁ´ØÂÆûÈôÖË∞ÉÁî®ÁöÑÁ´ØÁÇπ
app.post('/api/create-bot-enhanced', async (req, res) => {
  console.log('=== ÂâçÁ´ØÂ¢ûÂº∫ÁâàÂàõÂª∫BotËØ∑Ê±Ç ===');
  console.log('ËØ∑Ê±Ç‰Ωì:', JSON.stringify(req.body, null, 2));
  console.log('Content-Type:', req.headers['content-type']);
  
  try {
    const { 
      bot_name, 
      display_name,
      bot_token, 
      telegram_token,
      platform, 
      target_server,
      model,
      description,
      profession 
    } = req.body;
    
    // ÂèÇÊï∞È™åËØÅ
    const name = display_name || bot_name;
    const token = telegram_token || bot_token;
    const nodeId = target_server;
    
    if (!bot_name || !token || !nodeId) {
      return res.status(400).json({ 
        success: false,
        error: 'Áº∫Â∞ëÂøÖË¶ÅÂèÇÊï∞: bot_name, bot_token, target_server' 
      });
    }
    
    console.log(`ÂàõÂª∫Â¢ûÂº∫Bot: ${name}, ËäÇÁÇπ: ${nodeId}, Âπ≥Âè∞: ${platform}`);
    
    // È™åËØÅËäÇÁÇπÊòØÂê¶Â≠òÂú®
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(400).json({ 
        success: false,
        error: `ËäÇÁÇπ ${nodeId} ‰∏çÂ≠òÂú®` 
      });
    }
    
    // ÂÜôÂÖ•Êï∞ÊçÆÂ∫ì
    const botId = `bot-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const now = Date.now();
    
    const result = db.prepare(`
      INSERT INTO bots (id, name, node_id, bot_type, model, telegram_token, description, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      botId,
      name || 'New Bot',
      nodeId,
      'assistant',
      model || 'anthropic/claude-sonnet-4',
      token,
      description || `${name} - ${platform || 'telegram'}Âπ≥Âè∞Âä©ÁêÜ`,
      'created',
      now,
      now
    );
    
    const newBot = db.prepare('SELECT * FROM bots WHERE id = ?').get(botId);
    console.log(`Â¢ûÂº∫Bot ${name} ÂàõÂª∫ÊàêÂäü:`, newBot);
    
    // Ëá™Âä®ÈÉ®ÁΩ≤BotÂà∞ËäÇÁÇπ (ÂÆåÂÖ®Ëá™Âä®Âåñ)
    console.log(`ü§ñ ÂºÄÂßãËá™Âä®ÈÉ®ÁΩ≤Bot ${name} Âà∞ËäÇÁÇπ ${nodeId}`);
    
    try {
      const AutoBotDeployer = require('./auto-bot-deployer');
      const deployer = new AutoBotDeployer();
      
      // ÂºÇÊ≠•ÈÉ®ÁΩ≤Ôºå‰∏çÈòªÂ°ûÂìçÂ∫î
      deployer.deployBot(botId).then(deployResult => {
        deployer.close();
        if (deployResult.success) {
          console.log(`üéâ Bot ${name} Ëá™Âä®ÈÉ®ÁΩ≤ÊàêÂäü`);
        } else {
          console.log(`‚ö†Ô∏è Bot ${name} Ëá™Âä®ÈÉ®ÁΩ≤Â§±Ë¥•: ${deployResult.error}`);
        }
      }).catch(error => {
        deployer.close();
        console.log(`‚ùå Bot ${name} Ëá™Âä®ÈÉ®ÁΩ≤ÂºÇÂ∏∏: ${error.message}`);
      });
      
    } catch (error) {
      console.log(`‚ö†Ô∏è Ëá™Âä®ÈÉ®ÁΩ≤ÂêØÂä®Â§±Ë¥•: ${error.message}`);
    }

    res.json({
      success: true,
      message: `Bot ${name} ÂàõÂª∫ÊàêÂäüÔºåÊ≠£Âú®Ëá™Âä®ÈÉ®ÁΩ≤...`,
      bot: newBot,
      node_id: nodeId,
      template_used: 'enhanced-assistant',
      profession: profession || 'general',
      features: [
        '‚úÖ BotÈÖçÁΩÆÂ∑≤ÂÆåÊàê',
        '‚úÖ Êï∞ÊçÆÂ∫ìËÆ∞ÂΩïÂ∑≤ÂàõÂª∫', 
        'üöÄ Ê≠£Âú®Ëá™Âä®ÈÉ®ÁΩ≤Âà∞ËäÇÁÇπ...',
        '‚è≥ ÈÉ®ÁΩ≤ÂÆåÊàêÂêéÂç≥ÂèØ‰ΩøÁî®'
      ],
      auto_deploy: true,
      estimated_time: '30-60Áßí'
    });
    
  } catch (error) {
    console.error('ÂàõÂª∫Â¢ûÂº∫BotÈîôËØØ:', error);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// BotÈÉ®ÁΩ≤ÂíåÂêØÂä®API (ÁúüÊ≠£ÁöÑËá™Âä®ÂåñÈÉ®ÁΩ≤)
app.post('/api/bots/:botId/deploy-and-start', async (req, res) => {
  console.log(`=== ÂºÄÂßãÁúüÊ≠£ÈÉ®ÁΩ≤ÂíåÂêØÂä®Bot: ${req.params.botId} ===`);
  
  try {
    const { botId } = req.params;
    
    // ‰ΩøÁî®ÁúüÊ≠£ÁöÑËá™Âä®ÂåñÈÉ®ÁΩ≤Á≥ªÁªü
    const AutoBotDeployer = require('./auto-bot-deployer');
    const deployer = new AutoBotDeployer();
    
    const deployResult = await deployer.deployBot(botId);
    deployer.close();
    
    if (deployResult.success) {
      res.json({
        success: true,
        message: deployResult.message,
        bot_id: botId,
        status: deployResult.status,
        deployment_steps: [
          'üîç ËØªÂèñËäÇÁÇπOpenClawÈÖçÁΩÆ',
          'üìù ÁîüÊàêAgentÈÖçÁΩÆÊñá‰ª∂', 
          'üåê ÈÉ®ÁΩ≤ÈÖçÁΩÆÂà∞ËäÇÁÇπ',
          'üîÑ ÈáçÂêØOpenClawÊúçÂä°',
          '‚úÖ È™åËØÅBotËøêË°åÁä∂ÊÄÅ'
        ],
        next_steps: [
          'BotÂ∑≤ÁúüÊ≠£ÈÉ®ÁΩ≤Âà∞OpenClawËäÇÁÇπ',
          'Áé∞Âú®ÂèØ‰ª•Âú®Telegram‰∏≠ÊêúÁ¥¢Âπ∂ÊµãËØïBot',
          'BotÂ∞ÜËá™Âä®ÂìçÂ∫îÊ∂àÊÅØ',
          'ÂèØÂú®OCMÁïåÈù¢ÁõëÊéßËøêË°åÁä∂ÊÄÅ'
        ]
      });
    } else {
      res.status(500).json({
        success: false,
        error: deployResult.error
      });
    }
    
  } catch (error) {
    console.error('BotÈÉ®ÁΩ≤Á≥ªÁªüÈîôËØØ:', error);
    
    res.status(500).json({
      success: false,
      error: `ÈÉ®ÁΩ≤Á≥ªÁªüÈîôËØØ: ${error.message}`
    });
  }
});

// ÊâπÈáèÂêØÂä®ËäÇÁÇπ‰∏äÁöÑÊâÄÊúâBot (ÁúüÊ≠£ÁöÑËá™Âä®ÂåñÈÉ®ÁΩ≤)
app.post('/api/nodes/:nodeId/bots/deploy-all', async (req, res) => {
  console.log(`=== ÊâπÈáèÁúüÊ≠£ÈÉ®ÁΩ≤ËäÇÁÇπ ${req.params.nodeId} ÁöÑÊâÄÊúâBot ===`);
  
  try {
    const { nodeId } = req.params;
    
    // Ëé∑ÂèñËäÇÁÇπ‰∏äÁöÑÊâÄÊúâÂàõÂª∫Áä∂ÊÄÅÁöÑBot
    const bots = db.prepare(`
      SELECT * FROM bots 
      WHERE node_id = ? AND status IN ('created', 'stopped', 'error')
    `).all(nodeId);
    
    if (bots.length === 0) {
      return res.json({
        success: true,
        message: 'Ê≤°ÊúâÈúÄË¶ÅÈÉ®ÁΩ≤ÁöÑBot',
        deployed_bots: []
      });
    }
    
    const AutoBotDeployer = require('./auto-bot-deployer');
    const deployer = new AutoBotDeployer();
    
    const deployedBots = [];
    const failedBots = [];
    
    // ÈÄê‰∏ÄÈÉ®ÁΩ≤ÊØè‰∏™Bot
    for (const bot of bots) {
      console.log(`üöÄ ÈÉ®ÁΩ≤Bot: ${bot.name}`);
      
      try {
        const deployResult = await deployer.deployBot(bot.id);
        
        if (deployResult.success) {
          deployedBots.push({
            id: bot.id,
            name: bot.name,
            status: 'running'
          });
          console.log(`‚úÖ Bot ${bot.name} ÈÉ®ÁΩ≤ÊàêÂäü`);
        } else {
          failedBots.push({
            id: bot.id,
            name: bot.name,
            error: deployResult.error
          });
          console.log(`‚ùå Bot ${bot.name} ÈÉ®ÁΩ≤Â§±Ë¥•: ${deployResult.error}`);
        }
      } catch (error) {
        failedBots.push({
          id: bot.id,
          name: bot.name,
          error: error.message
        });
        console.log(`‚ùå Bot ${bot.name} ÈÉ®ÁΩ≤ÂºÇÂ∏∏: ${error.message}`);
      }
    }
    
    deployer.close();
    
    const successCount = deployedBots.length;
    const totalCount = bots.length;
    
    res.json({
      success: successCount > 0,
      message: `ÊâπÈáèÈÉ®ÁΩ≤ÂÆåÊàê: ${successCount}/${totalCount} ‰∏™BotÊàêÂäüÂêØÂä®`,
      deployed_bots: deployedBots,
      failed_bots: failedBots,
      node_id: nodeId,
      summary: {
        total: totalCount,
        success: successCount,
        failed: failedBots.length
      }
    });
    
  } catch (error) {
    console.error('ÊâπÈáèÈÉ®ÁΩ≤Á≥ªÁªüÈîôËØØ:', error);
    res.status(500).json({
      success: false,
      error: `ÊâπÈáèÈÉ®ÁΩ≤Á≥ªÁªüÈîôËØØ: ${error.message}`
    });
  }
});



// === Â¢ûÂº∫ÁöÑËäÇÁÇπ/BotÁÆ°ÁêÜÁ≥ªÁªüÈõÜÊàê ===
try {
  console.log('üîß ÂºÄÂßãÈõÜÊàêÂ¢ûÂº∫API...');
  const EnhancedBotCreationAPI = require('./enhanced-bot-creation-api');
  console.log('‚úÖ Â¢ûÂº∫APIÊ®°ÂùóÂä†ËΩΩÊàêÂäü');
  
  const enhancedBotAPI = new EnhancedBotCreationAPI(db);
  console.log('‚úÖ Â¢ûÂº∫APIÂÆû‰æãÂàõÂª∫ÊàêÂäü');
  
  app.use(enhancedBotAPI.getRouter());
  console.log('‚úÖ Â¢ûÂº∫ÁöÑËäÇÁÇπ/BotÁÆ°ÁêÜÁ≥ªÁªüÂ∑≤Âä†ËΩΩ');
  
} catch (error) {
  console.error('‚ùå Â¢ûÂº∫APIÈõÜÊàêÂ§±Ë¥•:', error);
}

// Ëá™Âä®ÂÆâË£Ö OpenClaw Âà∞ËäÇÁÇπ
async function installOpenClawToNode(node) {
  const { spawn } = require('child_process');
  const nodeInfo = JSON.stringify({
    host: node.host,
    user: node.ssh_user,
    name: node.name,
    openclaw_path: node.openclaw_path
  });
  
  console.log(`üîß ÂºÄÂßãÂÆâË£Ö OpenClaw Âà∞ ${node.id} (${node.host})`);
  
  try {
    // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫ÂÆâË£Ö‰∏≠
    db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
      .run('installing', Date.now(), node.id);
    
    // Ë∞ÉÁî®PythonÂÆâË£ÖËÑöÊú¨
    const installer = spawn('python3', [
      path.join(__dirname, 'enhanced-node-installer.py'),
      nodeInfo
    ]);
    
    let installOutput = '';
    let installError = '';
    
    installer.stdout.on('data', (data) => {
      const output = data.toString();
      installOutput += output;
      console.log(`[${node.id}] ${output.trim()}`);
    });
    
    installer.stderr.on('data', (data) => {
      const error = data.toString();
      installError += error;
      console.error(`[${node.id}] ERROR: ${error.trim()}`);
    });
    
    installer.on('close', (code) => {
      if (code === 0) {
        // ÂÆâË£ÖÊàêÂäü
        console.log(`‚úÖ ËäÇÁÇπ ${node.id} ÂÆâË£ÖÊàêÂäü`);
        
        db.prepare('UPDATE nodes SET status = ?, openclaw_version = ?, updated_at = ? WHERE id = ?')
          .run('online', '2026.2.13', Date.now(), node.id);
        
        db.prepare(`
          INSERT INTO events (node_id, type, severity, message, created_at)
          VALUES (?, 'install', 'info', ?, ?)
        `).run(node.id, `‚úÖ OpenClaw Ëá™Âä®ÂÆâË£ÖÂÆåÊàê`, Date.now());
        
        // Ëß¶ÂèëÂÅ•Â∫∑Ê£ÄÊü•
        setTimeout(() => {
          performHealthCheck(node.id);
        }, 5000);
        
      } else {
        // ÂÆâË£ÖÂ§±Ë¥•
        console.error(`‚ùå ËäÇÁÇπ ${node.id} ÂÆâË£ÖÂ§±Ë¥•ÔºåÈÄÄÂá∫Á†Å: ${code}`);
        
        db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
          .run('error', Date.now(), node.id);
        
        db.prepare(`
          INSERT INTO events (node_id, type, severity, message, created_at)
          VALUES (?, 'install', 'error', ?, ?)
        `).run(node.id, `‚ùå OpenClaw Ëá™Âä®ÂÆâË£ÖÂ§±Ë¥•: ${installError.trim() || 'Êú™Áü•ÈîôËØØ'}`, Date.now());
      }
    });
    
  } catch (error) {
    console.error(`ÂÆâË£ÖËøáÁ®ãÂºÇÂ∏∏ ${node.id}:`, error);
    
    db.prepare('UPDATE nodes SET status = ?, updated_at = ? WHERE id = ?')
      .run('error', Date.now(), node.id);
    
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message, created_at)
      VALUES (?, 'install', 'error', ?, ?)
    `).run(node.id, `‚ùå ÂÆâË£ÖËøáÁ®ãÂºÇÂ∏∏: ${error.message}`, Date.now());
  }
}

// ÁÆÄÂçïÂÅ•Â∫∑Ê£ÄÊü•
async function performHealthCheck(nodeId) {
  const { spawn } = require('child_process');
  const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
  
  if (!node) return;
  
  console.log(`üîç ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•: ${nodeId}`);
  
  const healthCheck = spawn('ssh', [
    '-o', 'ConnectTimeout=10',
    '-o', 'BatchMode=yes',
    `${node.ssh_user}@${node.host}`,
    'ps aux | grep -c openclaw; echo "CPU:$(top -bn1 | grep "Cpu(s)" | awk \'{print $2}\' | cut -d\'%\' -f1 || echo 0)"; echo "MEM:$(free | grep Mem | awk \'{printf("%.0f", $3/$2 * 100.0)}\' || echo 0)"'
  ]);
  
  let healthOutput = '';
  
  healthCheck.stdout.on('data', (data) => {
    healthOutput += data.toString();
  });
  
  healthCheck.on('close', (code) => {
    if (code === 0 && healthOutput.includes('openclaw')) {
      const lines = healthOutput.trim().split('\n');
      const processCount = parseInt(lines[0]) || 0;
      const cpuUsage = parseFloat(lines[1]?.replace('CPU:', '') || 0);
      const memUsage = parseFloat(lines[2]?.replace('MEM:', '') || 0);
      
      if (processCount > 0) {
        db.prepare(`
          UPDATE nodes 
          SET status = 'online', cpu_usage = ?, ram_usage = ?, last_seen_at = ?, updated_at = ?
          WHERE id = ?
        `).run(cpuUsage, memUsage, Date.now(), Date.now(), nodeId);
        
        db.prepare(`
          INSERT INTO events (node_id, type, severity, message, created_at)
          VALUES (?, 'health', 'info', ?, ?)
        `).run(nodeId, `‚úÖ ÂÅ•Â∫∑Ê£ÄÊü•ÈÄöËøáÔºåOpenClaw ËøêË°åÊ≠£Â∏∏`, Date.now());
        
        console.log(`‚úÖ ${nodeId} ÂÅ•Â∫∑Ê£ÄÊü•ÈÄöËøá`);
      } else {
        console.log(`‚ö†Ô∏è ${nodeId} OpenClaw ËøõÁ®ãÊú™Ê£ÄÊµãÂà∞`);
      }
    } else {
      console.log(`‚ö†Ô∏è ${nodeId} ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•`);
    }
  });
}

// AgentÂêåÊ≠•API
app.post('/api/nodes/:id/sync-agents', async (req, res) => {
  try {
    const { id } = req.params;
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(id);
    if (!node) {
      return res.status(404).json({ error: 'ËäÇÁÇπ‰∏çÂ≠òÂú®' });
    }

    const AgentSyncSystem = require('./sync-agents');
    const syncSystem = new AgentSyncSystem();
    
    await syncSystem.syncNodeAgents(id);
    syncSystem.close();

    // ËÆ∞ÂΩïÂêåÊ≠•‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message, created_at)
      VALUES (?, 'sync', 'info', ?, ?)
    `).run(id, `‚úÖ AgentÂêåÊ≠•ÂÆåÊàê`, Date.now());

    res.json({ 
      success: true, 
      message: `ËäÇÁÇπ ${id} ÁöÑAgentÂ∑≤ÊàêÂäüÂêåÊ≠•` 
    });
  } catch (error) {
    console.error('AgentÂêåÊ≠•Â§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ OCM Server running on http://localhost:${PORT}`);
});


// ÊµãËØïÂ¢ûÂº∫API
app.get('/api/test-enhanced', (req, res) => {
  res.json({ 
    message: 'Â¢ûÂº∫APIÊµãËØïÊàêÂäü', 
    timestamp: new Date().toISOString() 
  });
});

console.log('‚úÖ ÊµãËØïË∑ØÁî±Â∑≤Ê∑ªÂä†');

// BotÊô∫ËÉΩÂà†Èô§API (ÂÆåÂÖ®Âà†Èô§Âçï‰∏™Bot)
app.delete('/api/bots/:botId', async (req, res) => {
  console.log(`=== Êô∫ËÉΩÂà†Èô§Bot: ${req.params.botId} ===`);
  
  try {
    const { botId } = req.params;
    
    // ‰ΩøÁî®Êô∫ËÉΩBotÂà†Èô§Á≥ªÁªü
    const BotCleaner = require('./bot-cleaner');
    const cleaner = new BotCleaner();
    
    const deleteResult = await cleaner.deleteBot(botId);
    cleaner.close();
    
    if (deleteResult.success) {
      res.json({ 
        success: true,
        message: deleteResult.message,
        details: deleteResult.details,
        cleanup_steps: [
          'üîç Êô∫ËÉΩÂåπÈÖçË¶ÅÂà†Èô§ÁöÑAgent',
          'üóÑÔ∏è ‰ªéOCMÊï∞ÊçÆÂ∫ìÂà†Èô§ËÆ∞ÂΩï',
          deleteResult.details.removed_from_node ? 
            'üåê ‰ªéOpenClawËäÇÁÇπÂà†Èô§ÂåπÈÖçÈÖçÁΩÆ' : '‚ö†Ô∏è ËäÇÁÇπ‰∏≠Êó†ÂåπÈÖçÈÖçÁΩÆ',
          deleteResult.details.removed_from_node ? 
            'üîÑ ÈáçÂêØOpenClawÊúçÂä°' : '‚è© Ë∑≥ËøáÊúçÂä°ÈáçÂêØ',
          '‚úÖ Êô∫ËÉΩÂà†Èô§ÂÆåÊàê'
        ]
      });
    } else {
      res.status(500).json({
        success: false,
        error: deleteResult.error
      });
    }
    
  } catch (error) {
    console.error('BotÊô∫ËÉΩÂà†Èô§Á≥ªÁªüÈîôËØØ:', error);
    res.status(500).json({ 
      success: false,
      error: `Âà†Èô§Á≥ªÁªüÈîôËØØ: ${error.message}`
    });
  }
});

// ============ ÁúüÊ≠£Âà†Èô§ÂäüËÉΩAPI ============
app.delete('/api/bots/:botId/real-delete', async (req, res) => {
  try {
    const { botId } = req.params;
    console.log(`üóëÔ∏è ÁúüÊ≠£Âà†Èô§BotËØ∑Ê±Ç: ${botId}`);
    
    // Ëß£Êûêagent‰ø°ÊÅØ
    let agentId, nodeId;
    
    if (botId.startsWith('agent-')) {
      // Ê†ºÂºè: agent-main-timestamp Êàñ agent-agentname-timestamp  
      const parts = botId.split('-');
      agentId = parts[1] || 'main';
      nodeId = 'pc-b'; // ÁõÆÂâç‰∏ªË¶ÅÂú®pc-bÊµãËØï
    } else {
      agentId = botId;
      nodeId = 'pc-b';
    }
    
    console.log(`üìç Ëß£ÊûêÁªìÊûú: agentId=${agentId}, nodeId=${nodeId}`);
    
    // Ëé∑ÂèñËäÇÁÇπ‰ø°ÊÅØ
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
    if (!node) {
      return res.status(404).json({
        success: false,
        error: `ËäÇÁÇπ ${nodeId} ‰∏çÂ≠òÂú®`
      });
    }
    
    console.log(`üì° ÁõÆÊ†áËäÇÁÇπ: ${node.host}`);
    
    // ÊâßË°åÁúüÊ≠£Âà†Èô§
    const { spawn } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(require('child_process').exec);
    
    try {
      const sshTarget = `${node.ssh_user || 'openclaw02'}@${node.host}`;
      const openclawPath = node.openclaw_path || '/home/openclaw02/.openclaw';
      
      console.log(`üîß ÂºÄÂßãÂà†Èô§Agent ${agentId} ‰ªé ${sshTarget}`);
      
      // 1. Â§á‰ªΩÈÖçÁΩÆ
      await execAsync(`ssh ${sshTarget} "cd ${openclawPath} && cp openclaw.json openclaw.json.backup-delete-${Date.now()}"`);
      console.log('üì¶ Â∑≤Â§á‰ªΩÈÖçÁΩÆ');
      
      // 2. ‰ªéÈÖçÁΩÆ‰∏≠Âà†Èô§agent
      const removeScript = `
const fs = require('fs');
const config = JSON.parse(fs.readFileSync('openclaw.json'));
let modified = false;

// ‰ªéagents.listÂà†Èô§
if (config.agents && config.agents.list) {
  const before = config.agents.list.length;
  config.agents.list = config.agents.list.filter(agent => {
    const id = typeof agent === 'string' ? agent : agent.id;
    return id !== '${agentId}';
  });
  if (config.agents.list.length < before) modified = true;
}

// Âà†Èô§agentÈÖçÁΩÆ
if (config.agents && config.agents['${agentId}']) {
  delete config.agents['${agentId}'];
  modified = true;
}

// ‰ªébindingsÂà†Èô§  
if (config.bindings) {
  const before = config.bindings.length;
  config.bindings = config.bindings.filter(b => b.agentId !== '${agentId}');
  if (config.bindings.length < before) modified = true;
}

if (modified) {
  fs.writeFileSync('openclaw.json', JSON.stringify(config, null, 2));
  process.stdout.write('modified');
} else {
  process.stdout.write('unchanged');
}
`;
      
      await execAsync(`ssh ${sshTarget} "cd ${openclawPath} && node -e '${removeScript}'"`);
      console.log('‚öôÔ∏è ÈÖçÁΩÆÂà†Èô§ÂÆåÊàê');
      
      // 3. Âà†Èô§ÁõÆÂΩï
      await execAsync(`ssh ${sshTarget} "rm -rf ${openclawPath}/agents/${agentId} ${openclawPath}/workspace-${agentId}"`);
      console.log('üóÇÔ∏è ÁõÆÂΩïÂà†Èô§ÂÆåÊàê');
      
      // 4. ÈáçÂêØÊúçÂä°
      await execAsync(`ssh ${sshTarget} "systemctl --user restart openclaw-gateway"`);
      console.log('üîÑ ÊúçÂä°ÈáçÂêØÂÆåÊàê');
      
      // 5. ‰ªéÊï∞ÊçÆÂ∫ìÂà†Èô§
      try {
        const stmt = db.prepare('DELETE FROM bots WHERE id = ?');
        const result = stmt.run(botId);
        console.log(`üóÑÔ∏è Êï∞ÊçÆÂ∫ìÂà†Èô§: ${result.changes} Êù°ËÆ∞ÂΩï`);
      } catch (dbErr) {
        console.warn('Êï∞ÊçÆÂ∫ìÂà†Èô§Â§±Ë¥•:', dbErr.message);
      }
      
      console.log(`üéâ ÁúüÊ≠£Âà†Èô§ÂÆåÊàê: ${agentId}`);
      
      res.json({
        success: true,
        message: `Agent ${agentId} Â∑≤‰ªé ${node.host} ÂÆåÂÖ®Âà†Èô§`,
        details: {
          agentId: agentId,
          nodeHost: node.host,
          configUpdated: true,
          directoriesRemoved: true,
          serviceRestarted: true
        }
      });
      
    } catch (deleteError) {
      console.error('Âà†Èô§Êìç‰ΩúÂ§±Ë¥•:', deleteError);
      res.status(500).json({
        success: false,
        error: `Âà†Èô§Â§±Ë¥•: ${deleteError.message}`
      });
    }
    
  } catch (error) {
    console.error('ÁúüÊ≠£Âà†Èô§APIÈîôËØØ:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

console.log('‚úÖ ÁúüÊ≠£Âà†Èô§APIÂ∑≤Âä†ËΩΩ');

// ÁúüÊ≠£Âà†Èô§Agent API - Âü∫‰∫éÂ∑≤È™åËØÅÁöÑÊâãÂä®Âà†Èô§ÈÄªËæë
app.delete('/api/bots/:botId', async (req, res) => {
  try {
    const { botId } = req.params;
    console.log('üóëÔ∏è ÁúüÊ≠£Âà†Èô§Agent:', botId);
    
    // Ëß£ÊûêagentId (‰ªébotId‰∏≠ÊèêÂèñÂÆûÈôÖÁöÑagentÂêçÁß∞)
    let agentId;
    if (botId.startsWith('agent-')) {
      // Ê†ºÂºè: agent-Main_Standby_joe-timestamp
      const parts = botId.split('-');
      agentId = parts[1];
    } else {
      agentId = botId;
    }
    
    console.log('üéØ ÁõÆÊ†áAgent ID:', agentId);
    
    const { exec } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(exec);
    
    // ‰ΩøÁî®Â∑≤È™åËØÅÂèØÂ∑•‰ΩúÁöÑÂà†Èô§ÂëΩ‰ª§
    const realDeleteCmd = 'ssh openclaw02@192.168.3.17 "cd ~/.openclaw && cp openclaw.json openclaw.json.backup-ui-delete-1771207823 && python3 -c \"import json; f=open(\'openclaw.json\'); c=json.load(f); c[\'agents\'][\'list\']=[a for a in c[\'agents\'][\'list\'] if (a if isinstance(a,str) else a.get(\'id\'))!=\'' + agentId + '\']; f.close(); f=open(\'openclaw.json\',\'w\'); json.dump(c,f,indent=2); f.close()\" && systemctl --user restart openclaw-gateway"';
    
    await execAsync(realDeleteCmd);
    
    console.log('‚úÖ ÁúüÊ≠£Âà†Èô§ÂÆåÊàê:', agentId);
    
    res.json({
      success: true,
      message: 'Agent ' + agentId + ' Â∑≤‰ªéËäÇÁÇπÂÆåÂÖ®Âà†Èô§',
      real_delete: true
    });
    
  } catch (error) {
    console.error('‚ùå ÁúüÊ≠£Âà†Èô§Â§±Ë¥•:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

console.log('‚úÖ ÁúüÊ≠£Âà†Èô§APIÂ∑≤Âä†ËΩΩ');

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: "1.0.0"
  });
});
