/**
 * å¢å¼ºçš„Botåˆ›å»ºAPI - åŒ…å«èŠ‚ç‚¹å¥åº·æ£€æŸ¥
 * ç¡®ä¿åªæœ‰å¥åº·èŠ‚ç‚¹æ‰èƒ½åˆ›å»ºBot
 */

const express = require('express');
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const path = require('path');

const execAsync = promisify(exec);

class EnhancedBotCreationAPI {
    constructor(db) {
        this.db = db;
        this.router = express.Router();
        this.setupRoutes();
    }
    
    setupRoutes() {
            // ä¸“ä¸šé…ç½®API
        this.router.get("/api/professions", this.getProfessions.bind(this));
        
            // 1. èŠ‚ç‚¹å¥åº·æ£€æŸ¥API
        this.router.get('/api/nodes/:nodeId/health', this.checkNodeHealth.bind(this));
        
        // 2. èŠ‚ç‚¹Botæ·»åŠ èµ„æ ¼æ£€æŸ¥
        this.router.get('/api/nodes/:nodeId/bot-ready', this.checkBotReady.bind(this));
        
        // 3. å¢å¼ºçš„Botåˆ›å»ºAPI (æ›¿æ¢åŸæœ‰çš„)
        this.router.post('/api/create-bot-enhanced', this.createBotEnhanced.bind(this));
        
        // 4. æ‰¹é‡èŠ‚ç‚¹å¥åº·çŠ¶æ€
        this.router.get('/api/nodes/health/summary', this.getHealthSummary.bind(this));
        
        // 5. è§¦å‘èŠ‚ç‚¹å¥åº·æ£€æŸ¥
        this.router.post('/api/nodes/:nodeId/health-check', this.triggerHealthCheck.bind(this));
    }
    
    async checkNodeHealth(req, res) {
        try {
            const { nodeId } = req.params;
            
            // è·å–èŠ‚ç‚¹ä¿¡æ¯
            const node = this.db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
            if (!node) {
                return res.status(404).json({ error: 'èŠ‚ç‚¹ä¸å­˜åœ¨' });
            }
            
            // æ‰§è¡Œå¥åº·æ£€æŸ¥
            const healthResult = await this.performHealthCheck(node);
            
            // æ›´æ–°æ•°æ®åº“
            this.updateNodeHealth(nodeId, healthResult);
            
            res.json({
                success: true,
                node: {
                    id: node.id,
                    name: node.name,
                    host: node.host
                },
                health: healthResult,
                timestamp: new Date().toISOString()
            });
            
        } catch (error) {
            console.error('å¥åº·æ£€æŸ¥å¤±è´¥:', error);
            res.status(500).json({ error: error.message });
        }
    }
    
    async checkBotReady(req, res) {
        try {
            const { nodeId } = req.params;
            
            // è·å–èŠ‚ç‚¹ä¿¡æ¯
            const node = this.db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
            if (!node) {
                return res.status(404).json({ 
                    ready: false, 
                    reason: 'èŠ‚ç‚¹ä¸å­˜åœ¨' 
                });
            }
            
            // æ£€æŸ¥èŠ‚ç‚¹çŠ¶æ€
            const readyCheck = await this.isNodeReadyForBot(node);
            
            res.json({
                ready: readyCheck.ready,
                reason: readyCheck.reason,
                node: {
                    id: node.id,
                    name: node.name,
                    status: node.status,
                    last_score: node.last_score,
                    last_seen_at: node.last_seen_at
                },
                requirements: {
                    min_health_score: 70,
                    required_status: ['healthy', 'online', 'warning'],
                    max_age_minutes: 10
                }
            });
            
        } catch (error) {
            res.status(500).json({ 
                ready: false, 
                reason: `æ£€æŸ¥å¤±è´¥: ${error.message}` 
            });
        }
    }
    
    async createBotEnhanced(req, res) {
        try {
            const botData = req.body;
            console.log(`ğŸ¤– å¼€å§‹åˆ›å»ºBot: ${botData.bot_name} (å¢å¼ºç‰ˆ)`);
            
            // 1. å‚æ•°éªŒè¯
            const validationResult = this.validateBotData(botData);
            if (!validationResult.valid) {
                return res.status(400).json({ 
                    success: false,
                    error: `å‚æ•°éªŒè¯å¤±è´¥: ${validationResult.error}` 
                });
            }
            
            // 2. èŠ‚ç‚¹å¥åº·æ£€æŸ¥
            const nodeId = this.getNodeIdByServer(botData.target_server);
            if (!nodeId) {
                return res.status(400).json({
                    success: false,
                    error: `æœªçŸ¥çš„ç›®æ ‡æœåŠ¡å™¨: ${botData.target_server}`
                });
            }
            
            const node = this.db.prepare('SELECT * FROM nodes WHERE id = ?').get(nodeId);
            const readyCheck = await this.isNodeReadyForBot(node);
            
            if (!readyCheck.ready) {
                return res.status(400).json({
                    success: false,
                    error: `èŠ‚ç‚¹æœªå‡†å¤‡å°±ç»ª: ${readyCheck.reason}`,
                    node_status: {
                        name: node.name,
                        status: node.status,
                        health_score: node.last_score,
                        last_check: node.last_seen_at
                    }
                });
            }
            
            console.log(`âœ… èŠ‚ç‚¹å¥åº·æ£€æŸ¥é€šè¿‡: ${node.name}`);
            
            // 3. ç”ŸæˆBoté…ç½®
            const configResult = await this.generateBotConfig(botData);
            if (!configResult.success) {
                return res.status(500).json({
                    success: false,
                    error: `é…ç½®ç”Ÿæˆå¤±è´¥: ${configResult.error}`
                });
            }
            
            console.log(`âœ… Boté…ç½®ç”Ÿæˆå®Œæˆ: ${configResult.bundle_path}`);
            
            // 4. éƒ¨ç½²åˆ°ç›®æ ‡èŠ‚ç‚¹
            const deployResult = await this.deployBotToNode(configResult.bundle_path, node);
            if (!deployResult.success) {
                return res.status(500).json({
                    success: false,
                    error: `éƒ¨ç½²å¤±è´¥: ${deployResult.error}`,
                    config_path: configResult.bundle_path
                });
            }
            
            console.log(`âœ… Botéƒ¨ç½²å®Œæˆ: ${botData.bot_name}`);
            
            // 5. å†™å…¥æ•°æ®åº“
            const dbResult = this.saveBotToDatabase(botData, nodeId, {
                config_path: configResult.bundle_path,
                deploy_details: deployResult.details
            });
            
            // 6. éªŒè¯Botè¿è¡ŒçŠ¶æ€
            const verifyResult = await this.verifyBotDeployment(botData, node);
            
            res.json({
                success: true,
                message: `âœ… Bot ${botData.display_name || botData.bot_name} åˆ›å»ºæˆåŠŸ`,
                bot: {
                    id: dbResult.bot_id,
                    name: botData.bot_name,
                    display_name: botData.display_name,
                    profession: botData.profession || 'general',
                    node: node.name,
                    status: verifyResult.running ? 'running' : 'created'
                },
                deployment: {
                    config_path: configResult.bundle_path,
                    deployed_at: new Date().toISOString(),
                    verification: verifyResult
                },
                features: [
                    'âœ… åŸºäºJoeæ¨¡æ¿ï¼Œç»§æ‰¿æ ¸å¿ƒæŠ€èƒ½',
                    'âœ… ä¸“ä¸šåŒ–é…ç½®å·²åº”ç”¨',
                    'âœ… å·²å»é™¤ä¸ªäººä¿¡æ¯',
                    'âœ… é…ç½®åŒ…å·²ç”Ÿæˆå¹¶éƒ¨ç½²',
                    'âœ… å·²å†™å…¥æ•°æ®åº“',
                    'âœ… èŠ‚ç‚¹å¥åº·æ£€æŸ¥é€šè¿‡'
                ]
            });
            
        } catch (error) {
            console.error('Botåˆ›å»ºå¤±è´¥:', error);
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    async getHealthSummary(req, res) {
        try {
            const nodes = this.db.prepare(`
                SELECT id, name, status, last_score, last_seen_at, cpu_usage, ram_usage, disk_usage
                FROM nodes 
                ORDER BY last_score DESC
            `).all();
            
            const summary = {
                total_nodes: nodes.length,
                healthy_nodes: nodes.filter(n => n.status === 'healthy').length,
                warning_nodes: nodes.filter(n => n.status === 'warning').length,
                offline_nodes: nodes.filter(n => n.status === 'offline').length,
                avg_health_score: nodes.reduce((sum, n) => sum + (n.last_score || 0), 0) / nodes.length,
                nodes: nodes.map(node => ({
                    id: node.id,
                    name: node.name,
                    status: node.status,
                    health_score: node.last_score,
                    bot_ready: this.isNodeHealthy(node),
                    last_check: node.last_seen_at ? new Date(node.last_seen_at).toISOString() : null,
                    resources: {
                        cpu: node.cpu_usage,
                        memory: node.ram_usage,
                        disk: node.disk_usage
                    }
                }))
            };
            
            res.json(summary);
            
        } catch (error) {
            res.status(500).json({ error: error.message });
        }
    }
    
    async triggerHealthCheck(req, res) {
        try {
            const { nodeId } = req.params;
            
            // å¼‚æ­¥è§¦å‘å¥åº·æ£€æŸ¥
            console.log(`ğŸ” è§¦å‘èŠ‚ç‚¹å¥åº·æ£€æŸ¥: ${nodeId}`);
            
            // è°ƒç”¨Pythonå¥åº·ç›‘æ§è„šæœ¬
            const { stdout, stderr } = await execAsync(`python3 ${__dirname}/node-health-monitor.py ready ${nodeId}`);
            
            if (stderr) {
                console.error('å¥åº·æ£€æŸ¥è­¦å‘Š:', stderr);
            }
            
            const result = JSON.parse(stdout);
            
            res.json({
                success: true,
                message: 'å¥åº·æ£€æŸ¥å·²è§¦å‘',
                result: result
            });
            
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
    
    // --- è¾…åŠ©æ–¹æ³• ---
    
    validateBotData(botData) {
        const required = ['bot_name', 'bot_token', 'target_server'];
        const missing = required.filter(field => !botData[field]);
        
        if (missing.length > 0) {
            return { 
                valid: false, 
                error: `ç¼ºå°‘å¿…è¦å‚æ•°: ${missing.join(', ')}` 
            };
        }
        
        // Botåç§°æ ¼å¼æ£€æŸ¥
        if (!botData.bot_name.startsWith('@')) {
            return { 
                valid: false, 
                error: 'Botåç§°å¿…é¡»ä»¥@å¼€å¤´' 
            };
        }
        
        return { valid: true };
    }
    
    async isNodeReadyForBot(node) {
        if (!node) {
            return { ready: false, reason: 'èŠ‚ç‚¹ä¸å­˜åœ¨' };
        }
        
        // æ£€æŸ¥èŠ‚ç‚¹çŠ¶æ€
        const validStatuses = ['healthy', 'online', 'warning'];
        if (!validStatuses.includes(node.status)) {
            return { 
                ready: false, 
                reason: `èŠ‚ç‚¹çŠ¶æ€ä¸å¥åº·: ${node.status}` 
            };
        }
        
        // æ£€æŸ¥å¥åº·åˆ†æ•°
        const minScore = 70;
        if ((node.last_score || 0) < minScore) {
            return { 
                ready: false, 
                reason: `å¥åº·åˆ†æ•°è¿‡ä½: ${node.last_score || 0}/${minScore}` 
            };
        }
        
        // æ£€æŸ¥æœ€è¿‘æ£€æŸ¥æ—¶é—´ (10åˆ†é’Ÿå†…)
        const maxAge = 10 * 60 * 1000; // 10åˆ†é’Ÿ
        const now = Date.now();
        const lastSeen = node.last_seen_at || 0;
        
        if (now - lastSeen > maxAge) {
            return { 
                ready: false, 
                reason: 'èŠ‚ç‚¹çŠ¶æ€è¿‡æœŸï¼Œå»ºè®®è§¦å‘å¥åº·æ£€æŸ¥' 
            };
        }
        
        return { ready: true };
    }
    
    isNodeHealthy(node) {
        const check = this.isNodeReadyForBot(node);
        return check.ready;
    }
    
    getNodeIdByServer(serverName) {
        const serverMap = {
            'pc-a': ['pc-a', 'PC-A', '192.168.3.73'],
            't440': ['t440', 'T440', '192.168.3.33'],
            'baota': ['baota', 'Baota', '192.168.3.11'],
            'pc-b': ['pc-b', 'PC-B', '192.168.3.17']
        };
        
        for (const [key, aliases] of Object.entries(serverMap)) {
            if (aliases.some(alias => alias.toLowerCase() === serverName.toLowerCase())) {
                const node = this.db.prepare('SELECT id FROM nodes WHERE LOWER(name) LIKE ?').get(`%${key}%`);
                return node ? node.id : null;
            }
        }
        return null;
    }
    
    async generateBotConfig(botData) {
        try {
            const botInfoJson = JSON.stringify(botData);
            const { stdout, stderr } = await execAsync(
                `cd /home/linou/shared/ocm-project/server && python3 create_bot_api.py '${botInfoJson}'`
            );
            
            if (stderr) {
                console.error('é…ç½®ç”Ÿæˆè­¦å‘Š:', stderr);
            }
            
            // æå–é…ç½®åŒ…è·¯å¾„
            const bundlePath = stdout.match(/CONFIG_BUNDLE_PATH:(.+)/)?.[1]?.trim();
            if (!bundlePath) {
                return { success: false, error: 'æ— æ³•è·å–é…ç½®åŒ…è·¯å¾„' };
            }
            
            return { success: true, bundle_path: bundlePath };
            
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    async deployBotToNode(bundlePath, node) {
        try {
            console.log(`ğŸš€ å¼€å§‹éƒ¨ç½²åˆ°èŠ‚ç‚¹: ${node.name} (${node.host})`);
            
            // æ‰§è¡Œéƒ¨ç½²è„šæœ¬
            const deployCmd = `cd ${bundlePath} && chmod +x deploy.sh && ./deploy.sh`;
            const { stdout, stderr } = await execAsync(deployCmd, { timeout: 300000 }); // 5åˆ†é’Ÿè¶…æ—¶
            
            if (stderr && !stderr.includes('Warning')) {
                console.error('éƒ¨ç½²è­¦å‘Š:', stderr);
            }
            
            return {
                success: true,
                details: {
                    output: stdout,
                    warnings: stderr || null,
                    deployed_at: new Date().toISOString()
                }
            };
            
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
    
    saveBotToDatabase(botData, nodeId, deployInfo) {
        try {
            const result = this.db.prepare(`
                INSERT INTO bots (node_id, bot_name, bot_token, platform, workspace_path, model, status, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `).run(
                nodeId,
                botData.bot_name,
                botData.bot_token,
                'telegram',
                `/home/${this.getServerUser(botData.target_server)}/.openclaw/workspace-${botData.bot_name.replace('@', '').replace('_bot', '')}`,
                botData.model || 'claude-sonnet-4',
                'deployed',
                Date.now()
            );
            
            console.log(`âœ… Botå·²å†™å…¥æ•°æ®åº“ï¼ŒID: ${result.lastInsertRowid}`);
            
            return { bot_id: result.lastInsertRowid };
            
        } catch (error) {
            console.error('æ•°æ®åº“å†™å…¥å¤±è´¥:', error);
            return { bot_id: null, error: error.message };
        }
    }
    
    getServerUser(serverName) {
        const userMap = {
            'pc-a': 'openclaw01',
            'pc-b': 'openclaw02',
            't440': 'linou',
            'baota': 'linou'
        };
        return userMap[serverName.toLowerCase()] || 'linou';
    }
    
    async verifyBotDeployment(botData, node) {
        try {
            // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©æœåŠ¡å¯åŠ¨
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            // æ£€æŸ¥OpenClawè¿›ç¨‹
            const { stdout } = await execAsync(`ssh ${this.getServerUser(botData.target_server)}@${node.host} "ps aux | grep openclaw | grep -v grep"`);
            
            return {
                running: stdout.includes('openclaw'),
                process_info: stdout,
                verified_at: new Date().toISOString()
            };
            
        } catch (error) {
            return {
                running: false,
                error: error.message,
                verified_at: new Date().toISOString()
            };
        }
    }
    
    async performHealthCheck(node) {
        // è°ƒç”¨Pythonå¥åº·ç›‘æ§è„šæœ¬çš„å•æ¬¡æ£€æŸ¥
        try {
            const { stdout } = await execAsync(`python3 ${__dirname}/node-health-monitor.py check`);
            return JSON.parse(stdout);
        } catch (error) {
            return {
                success: false,
                error: error.message,
                score: 0
            };
        }
    }
    
    updateNodeHealth(nodeId, healthResult) {
        if (healthResult.success) {
            this.db.prepare(`
                UPDATE nodes 
                SET status = ?, last_score = ?, last_seen_at = ?, cpu_usage = ?, ram_usage = ?, disk_usage = ?
                WHERE id = ?
            `).run(
                healthResult.status || 'unknown',
                healthResult.score || 0,
                Date.now(),
                healthResult.cpu_usage || 0,
                healthResult.memory_usage || 0,
                healthResult.disk_usage || 0,
                nodeId
            );
        }
    }
    
        // è·å–ä¸“ä¸šåŒ–é€‰é¡¹
    getProfessions(req, res) {
        const professions = [
            {
                id: "game-dev",
                name: "æ¸¸æˆå¼€å‘ä¸“å®¶",
                description: "Unityã€Unreal Engineã€æ¸¸æˆè®¾è®¡",
                icon: "ğŸ®",
                skills: ["Unityå¼€å‘", "C#ç¼–ç¨‹", "æ¸¸æˆè®¾è®¡", "æ€§èƒ½ä¼˜åŒ–"]
            },
            {
                id: "data-eng", 
                name: "æ•°æ®å·¥ç¨‹ä¸“å®¶",
                description: "æ•°æ®ç®¡é“ã€ETLã€å¤§æ•°æ®å¤„ç†",
                icon: "ğŸ“Š",
                skills: ["Python", "SQL", "Spark", "æ•°æ®å»ºæ¨¡"]
            },
            {
                id: "general",
                name: "é€šç”¨åŠ©ç†",
                description: "å…¨èƒ½AIåŠ©ç†ï¼Œé€‚ç”¨äºå„ç§ä»»åŠ¡",
                icon: "ğŸ¤–",
                skills: ["é€šç”¨å¯¹è¯", "ä»»åŠ¡ååŠ©", "ä¿¡æ¯æŸ¥è¯¢", "æ–‡æ¡£å¤„ç†"]
            }
        ];
        res.json({ professions });
    }

    getRouter() {
        return this.router;
    }
}

module.exports = EnhancedBotCreationAPI;