const express = require('express');
const nodeManagementRouter = require('./node-management-api');
const cors = require('cors');
const path = require('path');
const Database = require('better-sqlite3');

const app = express();
const PORT = 8001;

// Database
const dbPath = path.join(__dirname, 'db', 'ocm.db');
const db = new Database(dbPath);
db.pragma('journal_mode = WAL');

// Middleware
app.use(cors());
app.use(express.json());

// API Routes
app.use(nodeManagementRouter);

// Dashboard - ÂÖ®ÈáèÊï∞ÊçÆ
app.get('/api/dashboard', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes ORDER BY id').all();
    
    // ÊØè‰∏™ËäÇÁÇπÊ∑ªÂä† bot Êï∞Èáè
    nodes.forEach(node => {
      const botCount = db.prepare('SELECT COUNT(*) as count FROM bots WHERE node_id = ?').get(node.id).count;
      node.bot_count = botCount;
    });
    
    const events = db.prepare('SELECT * FROM events ORDER BY created_at DESC LIMIT 10').all();
    
    const onlineCount = nodes.filter(n => n.status === 'online').length;
    const avgScore = Math.floor(
      nodes.filter(n => n.last_score).reduce((sum, n) => sum + n.last_score, 0) / 
      nodes.filter(n => n.last_score).length
    ) || 0;
    
    const todayBackups = db.prepare(`
      SELECT COUNT(*) as count FROM backups 
      WHERE created_at > ?
    `).get(Date.now() - 86400000).count;

    // Êô∫ÂäõË∂ãÂäøÊï∞ÊçÆÔºàÊúÄËøë7Â§©Ôºâ
    const sevenDaysAgo = Date.now() - 7 * 24 * 3600000;
    const trendScores = db.prepare(`
      SELECT node_id, total_score, created_at 
      FROM scores 
      WHERE created_at > ?
      ORDER BY created_at ASC
    `).all(sevenDaysAgo);

    // ÊåâÊó•ÊúüÂàÜÁªÑ
    const trendMap = {};
    trendScores.forEach(score => {
      const date = new Date(score.created_at).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' });
      if (!trendMap[date]) trendMap[date] = {};
      trendMap[date][score.node_id] = score.total_score;
    });

    const trendData = Object.keys(trendMap).map(date => ({
      date,
      ...trendMap[date]
    }));

    // Phase 7: Additional stats
    const totalSessions = db.prepare('SELECT COUNT(*) as count FROM sessions').get().count;
    const activeSessions = db.prepare('SELECT COUNT(*) as count FROM sessions WHERE is_active = 1').get().count;
    const totalCronJobs = db.prepare('SELECT COUNT(*) as count FROM cron_jobs').get().count;
    const enabledCronJobs = db.prepare('SELECT COUNT(*) as count FROM cron_jobs WHERE enabled = 1').get().count;
    const totalSkills = db.prepare('SELECT COUNT(*) as count FROM skills').get().count;
    const memoryWarnings = db.prepare(`
      SELECT COUNT(*) as count FROM memory_health 
      WHERE health_status != 'healthy' 
      AND id IN (
        SELECT MAX(id) FROM memory_health GROUP BY bot_id
      )
    `).get().count;

    res.json({
      overview: {
        totalNodes: nodes.length,
        onlineCount,
        offlineCount: nodes.length - onlineCount,
        avgScore,
        todayBackups,
        alerts: nodes.filter(n => n.last_score && n.last_score < 80).length,
        totalSessions,
        activeSessions,
        totalCronJobs,
        enabledCronJobs,
        totalSkills,
        memoryWarnings,
      },
      nodes,
      events,
      trendData,
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπÂàóË°®
app.get('/api/nodes', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes ORDER BY id').all();
    res.json(nodes);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†ËäÇÁÇπ (Phase 6 CRUD)
app.post('/api/nodes', (req, res) => {
  try {
    const { id, name, host, port, ssh_user, openclaw_path } = req.body;
    const result = db.prepare(`
      INSERT INTO nodes (id, name, host, port, ssh_user, openclaw_path, status, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, 'unknown', ?, ?)
    `).run(id, name, host, port || 22, ssh_user || 'ocm', openclaw_path || '/home/ocm/.openclaw', Date.now(), Date.now());
    
    const newNode = db.prepare('SELECT * FROM nodes WHERE id = ?').get(id);
    res.json(newNode);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞ËäÇÁÇπ (Phase 6 CRUD)
app.put('/api/nodes/:id', (req, res) => {
  try {
    const { name, host, port, ssh_user, openclaw_path, tags } = req.body;
    db.prepare(`
      UPDATE nodes 
      SET name = ?, host = ?, port = ?, ssh_user = ?, openclaw_path = ?, tags = ?, updated_at = ?
      WHERE id = ?
    `).run(name, host, port, ssh_user, openclaw_path, tags, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§ËäÇÁÇπ (Phase 6 CRUD)
app.delete('/api/nodes/:id', (req, res) => {
  try {
    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ≥ËÅîÊï∞ÊçÆ
    const botsCount = db.prepare('SELECT COUNT(*) as count FROM bots WHERE node_id = ?').get(req.params.id).count;
    const keysCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE node_id = ?').get(req.params.id).count;
    
    if (botsCount > 0 || keysCount > 0) {
      return res.status(400).json({ 
        error: `ËØ•ËäÇÁÇπ‰∏ãËøòÊúâ ${botsCount} ‰∏™ Bot Âíå ${keysCount} ‰∏™ KeyÔºåÊó†Ê≥ïÂà†Èô§` 
      });
    }
    
    db.prepare('DELETE FROM nodes WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËäÇÁÇπËØ¶ÊÉÖ
app.get('/api/nodes/:id', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) {
      return res.status(404).json({ error: 'Node not found' });
    }

    const backups = db.prepare(`
      SELECT * FROM backups WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 10
    `).all(req.params.id);

    const scores = db.prepare(`
      SELECT * FROM scores WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 10
    `).all(req.params.id);

    const events = db.prepare(`
      SELECT * FROM events WHERE node_id = ? 
      ORDER BY created_at DESC LIMIT 20
    `).all(req.params.id);

    res.json({ node, backups, scores, events });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Â§á‰ªΩÂàóË°®
app.get('/api/nodes/:id/backups', (req, res) => {
  try {
    const backups = db.prepare(`
      SELECT * FROM backups WHERE node_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.id);
    res.json(backups);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êô∫ÂäõËØÑÂàÜÂéÜÂè≤
app.get('/api/nodes/:id/scores', (req, res) => {
  try {
    const scores = db.prepare(`
      SELECT * FROM scores WHERE node_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.id);
    res.json(scores);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ‰∫ã‰ª∂Êó•Âøó (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/events', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, severity, type, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (severity && severity !== 'all') {
      whereClause.push('severity = ?');
      params.push(severity);
    }
    if (type && type !== 'all') {
      whereClause.push('type = ?');
      params.push(type);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM events ${whereSQL}`).get(...params).count;
    const events = db.prepare(`
      SELECT * FROM events 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: events,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈÉ®Â§á‰ªΩ (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/backups', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, type, is_stable, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (type && type !== 'all') {
      whereClause.push('type = ?');
      params.push(type);
    }
    if (is_stable === '1') {
      whereClause.push('is_stable = 1');
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM backups ${whereSQL}`).get(...params).count;
    const backups = db.prepare(`
      SELECT * FROM backups 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: backups,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§Â§á‰ªΩ (Phase 6 CRUD)
app.delete('/api/backups/:id', (req, res) => {
  try {
    db.prepare('DELETE FROM backups WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÁªôÂ§á‰ªΩÊ∑ªÂä†Ê†áÁ≠æ (Phase 6)
app.put('/api/backups/:id/tag', (req, res) => {
  try {
    const { git_tag, is_stable } = req.body;
    db.prepare(`
      UPDATE backups 
      SET git_tag = ?, is_stable = ?
      WHERE id = ?
    `).run(git_tag, is_stable ? 1 : 0, req.params.id);
    
    const updated = db.prepare('SELECT * FROM backups WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈÉ®ËØÑÂàÜÂéÜÂè≤ (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/scores/all', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { node_id, minScore, maxScore, action_taken, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('node_id = ?');
      params.push(node_id);
    }
    if (minScore) {
      whereClause.push('total_score >= ?');
      params.push(parseInt(minScore));
    }
    if (maxScore) {
      whereClause.push('total_score <= ?');
      params.push(parseInt(maxScore));
    }
    if (action_taken && action_taken !== 'all') {
      whereClause.push('action_taken = ?');
      params.push(action_taken);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM scores ${whereSQL}`).get(...params).count;
    const scores = db.prepare(`
      SELECT * FROM scores 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: scores,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Accounts ÁÆ°ÁêÜ ============

// Ëé∑ÂèñÊâÄÊúâË¥¶Âè∑
app.get('/api/accounts', (req, res) => {
  try {
    const accounts = db.prepare('SELECT * FROM accounts ORDER BY provider, id').all();
    
    // ÊØè‰∏™Ë¥¶Âè∑Ê∑ªÂä† key Êï∞Èáè
    accounts.forEach(account => {
      const keyCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE account_id = ?').get(account.id).count;
      account.key_count = keyCount;
    });
    
    res.json(accounts);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†Ë¥¶Âè∑
app.post('/api/accounts', (req, res) => {
  try {
    const { provider, account_name, email, plan, monthly_budget, status, note } = req.body;
    const result = db.prepare(`
      INSERT INTO accounts (provider, account_name, email, plan, monthly_budget, status, note)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(provider, account_name, email || '', plan || 'free', monthly_budget || 0, status || 'active', note || '');
    
    const newAccount = db.prepare('SELECT * FROM accounts WHERE id = ?').get(result.lastInsertRowid);
    res.json(newAccount);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞Ë¥¶Âè∑
app.put('/api/accounts/:id', (req, res) => {
  try {
    const { account_name, email, plan, monthly_budget, monthly_used, status, note } = req.body;
    db.prepare(`
      UPDATE accounts 
      SET account_name = ?, email = ?, plan = ?, monthly_budget = ?, monthly_used = ?, status = ?, note = ?, updated_at = ?
      WHERE id = ?
    `).run(account_name, email, plan, monthly_budget, monthly_used, status, note, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM accounts WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§Ë¥¶Âè∑
app.delete('/api/accounts/:id', (req, res) => {
  try {
    // ÂÖàÊ£ÄÊü•ÊòØÂê¶ÊúâÂÖ≥ËÅîÁöÑkeys
    const keyCount = db.prepare('SELECT COUNT(*) as count FROM api_keys WHERE account_id = ?').get(req.params.id).count;
    if (keyCount > 0) {
      return res.status(400).json({ error: 'ËØ•Ë¥¶Âè∑‰∏ãËøòÊúâ API KeysÔºåÊó†Ê≥ïÂà†Èô§' });
    }
    
    db.prepare('DELETE FROM accounts WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ëé∑ÂèñË¥¶Âè∑‰∏ãÁöÑÊâÄÊúâkeys
app.get('/api/accounts/:id/keys', (req, res) => {
  try {
    const keys = db.prepare('SELECT * FROM api_keys WHERE account_id = ? ORDER BY created_at DESC').all(req.params.id);
    res.json(keys);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ API Keys ÁÆ°ÁêÜ ============

// Ëé∑ÂèñËäÇÁÇπÁöÑÊâÄÊúâkeys
app.get('/api/nodes/:id/keys', (req, res) => {
  try {
    const keys = db.prepare('SELECT * FROM api_keys WHERE node_id = ? ORDER BY created_at DESC').all(req.params.id);
    res.json(keys);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†key
app.post('/api/nodes/:id/keys', (req, res) => {
  try {
    const { provider, key_name, api_key, monthly_limit, note } = req.body;
    const result = db.prepare(`
      INSERT INTO api_keys (node_id, provider, key_name, api_key, monthly_limit, note)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(req.params.id, provider, key_name, api_key, monthly_limit || null, note || '');
    
    const newKey = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(result.lastInsertRowid);
    res.json(newKey);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞key
app.put('/api/keys/:keyId', (req, res) => {
  try {
    const { key_name, api_key, is_active, monthly_limit, note } = req.body;
    db.prepare(`
      UPDATE api_keys 
      SET key_name = ?, api_key = ?, is_active = ?, monthly_limit = ?, note = ?, updated_at = ?
      WHERE id = ?
    `).run(key_name, api_key, is_active, monthly_limit, note, Date.now(), req.params.keyId);
    
    const updated = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(req.params.keyId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§key
app.delete('/api/keys/:keyId', (req, res) => {
  try {
    db.prepare('DELETE FROM api_keys WHERE id = ?').run(req.params.keyId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// È™åËØÅkey
app.post('/api/keys/:keyId/verify', (req, res) => {
  try {
    // Mock: ÈöèÊú∫ËøîÂõû valid/invalid
    const status = Math.random() > 0.2 ? 'valid' : 'invalid';
    db.prepare(`
      UPDATE api_keys 
      SET status = ?, last_verified_at = ?
      WHERE id = ?
    `).run(status, Date.now(), req.params.keyId);
    
    const updated = db.prepare('SELECT * FROM api_keys WHERE id = ?').get(req.params.keyId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§keyÂàóË°® (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/keys', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { provider, account_id, node_id, status } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (provider && provider !== 'all') {
      whereClause.push('k.provider = ?');
      params.push(provider);
    }
    if (account_id && account_id !== 'all') {
      whereClause.push('k.account_id = ?');
      params.push(parseInt(account_id));
    }
    if (node_id && node_id !== 'all') {
      whereClause.push('k.node_id = ?');
      params.push(node_id);
    }
    if (status && status !== 'all') {
      whereClause.push('k.status = ?');
      params.push(status);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`
      SELECT COUNT(*) as count 
      FROM api_keys k
      LEFT JOIN accounts a ON k.account_id = a.id
      ${whereSQL}
    `).get(...params).count;
    
    const keys = db.prepare(`
      SELECT k.*, a.account_name, a.plan 
      FROM api_keys k
      LEFT JOIN accounts a ON k.account_id = a.id
      ${whereSQL}
      ORDER BY k.node_id, k.provider
      LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: keys,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Bots ÁÆ°ÁêÜ ============

// Ëé∑ÂèñËäÇÁÇπÁöÑÊâÄÊúâbots
app.get('/api/nodes/:id/bots', (req, res) => {
  try {
    const bots = db.prepare('SELECT * FROM bots WHERE node_id = ? ORDER BY created_at').all(req.params.id);
    res.json(bots);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†bot
app.post('/api/nodes/:id/bots', (req, res) => {
  try {
    const { bot_name, bot_token, platform, workspace_path, model, openclaw_url } = req.body;
    const result = db.prepare(`
      INSERT INTO bots (node_id, bot_name, bot_token, platform, workspace_path, model, openclaw_url)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(req.params.id, bot_name, bot_token, platform || 'telegram', workspace_path, model, openclaw_url);
    
    const newBot = db.prepare('SELECT * FROM bots WHERE id = ?').get(result.lastInsertRowid);
    res.json(newBot);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞bot
app.put('/api/bots/:botId', (req, res) => {
  try {
    const { bot_name, status, model, session_count, cron_count } = req.body;
    db.prepare(`
      UPDATE bots 
      SET bot_name = ?, status = ?, model = ?, session_count = ?, cron_count = ?, updated_at = ?
      WHERE id = ?
    `).run(bot_name, status, model, session_count, cron_count, Date.now(), req.params.botId);
    
    const updated = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§bot
app.delete('/api/bots/:botId', (req, res) => {
  try {
    db.prepare('DELETE FROM bots WHERE id = ?').run(req.params.botId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§botÂàóË°®
app.get('/api/bots', (req, res) => {
  try {
    const bots = db.prepare('SELECT * FROM bots ORDER BY node_id').all();
    res.json(bots);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Bot Backups (Phase 6) ============

// Ëé∑Âèñ Bot ÁöÑÂ§á‰ªΩÂàóË°®
app.get('/api/bots/:botId/backups', (req, res) => {
  try {
    const backups = db.prepare(`
      SELECT * FROM bot_backups 
      WHERE bot_id = ? 
      ORDER BY created_at DESC
    `).all(req.params.botId);
    res.json(backups);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ëß¶Âèë Bot Â§á‰ªΩ
app.post('/api/bots/:botId/backups', (req, res) => {
  try {
    const bot = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    if (!bot) {
      return res.status(404).json({ error: 'Bot not found' });
    }

    const { type = 'manual', note = '' } = req.body;
    
    // Mock: ÂàõÂª∫Â§á‰ªΩËÆ∞ÂΩï
    const result = db.prepare(`
      INSERT INTO bot_backups (bot_id, node_id, git_commit, type, file_count, total_size, note)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      req.params.botId,
      bot.node_id,
      Math.random().toString(36).substring(7), // mock commit hash
      type,
      Math.floor(Math.random() * 100) + 150,
      Math.floor(Math.random() * 5000000) + 8000000,
      note
    );
    
    const newBackup = db.prepare('SELECT * FROM bot_backups WHERE id = ?').get(result.lastInsertRowid);
    res.json(newBackup);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËøòÂéü Bot Âà∞ÊåáÂÆöÂ§á‰ªΩ
app.post('/api/bots/:botId/restore', (req, res) => {
  try {
    const { backup_id } = req.body;
    const backup = db.prepare('SELECT * FROM bot_backups WHERE id = ? AND bot_id = ?')
      .get(backup_id, req.params.botId);
    
    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' });
    }
    
    // Mock: ÂÆûÈôÖ‰ºöÊâßË°åËøòÂéüÊìç‰Ωú
    res.json({ 
      success: true, 
      message: `Bot ${req.params.botId} Â∑≤ËøòÂéüÂà∞Â§á‰ªΩ ${backup_id}`,
      backup
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§ Bot Â§á‰ªΩ
app.delete('/api/bots/:botId/backups/:backupId', (req, res) => {
  try {
    db.prepare('DELETE FROM bot_backups WHERE id = ? AND bot_id = ?')
      .run(req.params.backupId, req.params.botId);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Phase 7: New Modules ============

// Memory Health
app.get('/api/bots/:botId/memory-health', (req, res) => {
  try {
    const health = db.prepare(`
      SELECT * FROM memory_health 
      WHERE bot_id = ? 
      ORDER BY checked_at DESC
    `).all(req.params.botId);
    res.json(health);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Sessions
app.get('/api/bots/:botId/sessions', (req, res) => {
  try {
    const sessions = db.prepare(`
      SELECT * FROM sessions 
      WHERE bot_id = ? 
      ORDER BY is_active DESC, last_activity_at DESC
    `).all(req.params.botId);
    res.json(sessions);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/sessions', (req, res) => {
  try {
    const sessions = db.prepare(`
      SELECT s.*, b.bot_name 
      FROM sessions s
      LEFT JOIN bots b ON s.bot_id = b.id
      ORDER BY s.is_active DESC, s.last_activity_at DESC
    `).all();
    
    const totalCount = sessions.length;
    const activeCount = sessions.filter(s => s.is_active).length;
    
    res.json({
      data: sessions,
      total: totalCount,
      active: activeCount
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Cron Jobs
app.get('/api/bots/:botId/cron-jobs', (req, res) => {
  try {
    const jobs = db.prepare(`
      SELECT * FROM cron_jobs 
      WHERE bot_id = ? 
      ORDER BY enabled DESC, created_at DESC
    `).all(req.params.botId);
    res.json(jobs);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/cron-jobs', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    const { node_id, bot_id, enabled, schedule_type } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (node_id && node_id !== 'all') {
      whereClause.push('c.node_id = ?');
      params.push(node_id);
    }
    if (bot_id && bot_id !== 'all') {
      whereClause.push('c.bot_id = ?');
      params.push(parseInt(bot_id));
    }
    if (enabled === '1' || enabled === '0') {
      whereClause.push('c.enabled = ?');
      params.push(parseInt(enabled));
    }
    if (schedule_type && schedule_type !== 'all') {
      whereClause.push('c.schedule_type = ?');
      params.push(schedule_type);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`
      SELECT COUNT(*) as count 
      FROM cron_jobs c
      ${whereSQL}
    `).get(...params).count;
    
    const jobs = db.prepare(`
      SELECT c.*, b.bot_name, b.agent_emoji
      FROM cron_jobs c
      LEFT JOIN bots b ON c.bot_id = b.id
      ${whereSQL}
      ORDER BY c.enabled DESC, c.last_run_at DESC
      LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: jobs,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Toggle cron job
app.put('/api/cron-jobs/:id/toggle', (req, res) => {
  try {
    const job = db.prepare('SELECT * FROM cron_jobs WHERE id = ?').get(req.params.id);
    if (!job) return res.status(404).json({ error: 'Job not found' });
    
    const newEnabled = job.enabled ? 0 : 1;
    db.prepare('UPDATE cron_jobs SET enabled = ? WHERE id = ?').run(newEnabled, req.params.id);
    
    const updated = db.prepare('SELECT * FROM cron_jobs WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Gateway Config
app.get('/api/nodes/:id/config', (req, res) => {
  try {
    const config = db.prepare(`
      SELECT * FROM gateway_configs 
      WHERE node_id = ?
    `).get(req.params.id);
    res.json(config || {});
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Skills
app.get('/api/nodes/:id/skills', (req, res) => {
  try {
    const skills = db.prepare(`
      SELECT * FROM skills 
      WHERE node_id = ? 
      ORDER BY source, skill_name
    `).all(req.params.id);
    res.json(skills);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/skills', (req, res) => {
  try {
    const skills = db.prepare(`
      SELECT s.*, n.name as node_name 
      FROM skills s
      LEFT JOIN nodes n ON s.node_id = n.id
      ORDER BY s.node_id, s.source, s.skill_name
    `).all();
    
    const totalCount = skills.length;
    const bundledCount = skills.filter(s => s.source === 'bundled').length;
    const customCount = skills.filter(s => s.source === 'custom' || s.source === 'workspace').length;
    
    res.json({
      data: skills,
      total: totalCount,
      bundled: bundledCount,
      custom: customCount
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Audit Log ============

// Ëé∑ÂèñÂÆ°ËÆ°Êó•Âøó (ÂàÜÈ°µ + Á≠õÈÄâ)
app.get('/api/audit', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    // Á≠õÈÄâÂèÇÊï∞
    const { operator, action, result, dateFrom, dateTo } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (operator) {
      whereClause.push('operator = ?');
      params.push(operator);
    }
    if (action) {
      whereClause.push('action = ?');
      params.push(action);
    }
    if (result) {
      whereClause.push('result = ?');
      params.push(result);
    }
    if (dateFrom) {
      whereClause.push('created_at >= ?');
      params.push(parseInt(dateFrom));
    }
    if (dateTo) {
      whereClause.push('created_at <= ?');
      params.push(parseInt(dateTo));
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM audit_log ${whereSQL}`).get(...params).count;
    const logs = db.prepare(`
      SELECT * FROM audit_log 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    res.json({
      data: logs,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∑ªÂä†ÂÆ°ËÆ°Êó•Âøó
app.post('/api/audit', (req, res) => {
  try {
    const { operator, operator_detail, action, target, params, result, error_message, duration_ms } = req.body;
    const result_insert = db.prepare(`
      INSERT INTO audit_log (operator, operator_detail, action, target, params, result, error_message, duration_ms)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(operator, operator_detail || '', action, target || '', params || '', result || 'success', error_message || '', duration_ms || 0);
    
    const newLog = db.prepare('SELECT * FROM audit_log WHERE id = ?').get(result_insert.lastInsertRowid);
    res.json(newLog);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ ËäÇÁÇπÊìç‰Ωú API ============

// Â§á‰ªΩËäÇÁÇπ
app.post('/api/nodes/:id/backup', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÂàõÂª∫Â§á‰ªΩËÆ∞ÂΩï
    const { type = 'manual' } = req.body;
    const result = db.prepare(`
      INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
      VALUES (?, ?, ?, ?, ?)
    `).run(
      req.params.id,
      type,
      Math.random().toString(36).substring(2, 9), // mock commit
      Math.floor(Math.random() * 200) + 150,
      Math.floor(Math.random() * 10000000) + 8000000
    );

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'backup', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â§á‰ªΩÂÆåÊàê`);

    const newBackup = db.prepare('SELECT * FROM backups WHERE id = ?').get(result.lastInsertRowid);
    res.json({ success: true, backup: newBackup, message: '‚úÖ Â§á‰ªΩÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËøòÂéüËäÇÁÇπ
app.post('/api/nodes/:id/restore', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    const { backup_id } = req.body;
    const backup = db.prepare('SELECT * FROM backups WHERE id = ?').get(backup_id);
    if (!backup) return res.status(404).json({ error: 'Backup not found' });

    // Mock: ËøòÂéüÊìç‰Ωú
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restore', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â∑≤ËøòÂéüÂà∞Â§á‰ªΩ ${backup.git_commit}`);
    
    // ÁúüÊ≠£ÁöÑËøòÂéüÊìç‰Ωú
    try {
      const { spawn } = require('child_process');
      const restoreProcess = spawn('python3', ['smart_restore_system.py', 'restore', req.params.id, backup_id.toString()], {
        cwd: __dirname,
        stdio: 'inherit'  // Áõ¥Êé•ËæìÂá∫Âà∞ÊéßÂà∂Âè∞Ôºå‰∏çÁ≠âÂæÖÁªìÊûú
      });
      
      // ‰∏çÁ≠âÂæÖÂÆåÊàêÔºåÁ´ãÂç≥ËøîÂõûÔºàÂºÇÊ≠•ÊâßË°åÔºâ
      console.log(`Ê≠£Âú®ÂêéÂè∞ÊâßË°åËøòÂéü: ${req.params.id} -> Â§á‰ªΩ${backup_id}`);
      
    } catch (restoreError) {
      console.error('ËøòÂéüÊâßË°åÈîôËØØ:', restoreError);
    }

    res.json({ 
      success: true, 
      message: `‚úÖ ËäÇÁÇπËøòÂéüÂ∑≤Êèê‰∫§ÊâßË°å\nÂ§á‰ªΩ: ${backup.git_commit}\n‚è≥ ÂêéÂè∞ÊâßË°å‰∏≠ÔºåËØ∑Á≠âÂæÖ1-2ÂàÜÈíüÂêéÊ£ÄÊü•ËäÇÁÇπÁä∂ÊÄÅÊàñÊâãÂä®ÈáçÂêØOpenClawÊúçÂä°` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈáçÂêØËäÇÁÇπ
app.post('/api/nodes/:id/restart', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÈáçÂêØÊìç‰Ωú
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restart', 'info', ?)
    `).run(req.params.id, `ËäÇÁÇπ ${req.params.id} Â∑≤ÈáçÂêØ`);

    res.json({ 
      success: true, 
      message: `‚úÖ ËäÇÁÇπÂ∑≤ÈáçÂêØÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊâßË°å SSH + systemctl restart openclaw` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êô∫ÂäõÊµãËØïËäÇÁÇπ
app.post('/api/nodes/:id/test', (req, res) => {
  try {
    const node = db.prepare('SELECT * FROM nodes WHERE id = ?').get(req.params.id);
    if (!node) return res.status(404).json({ error: 'Node not found' });

    // Mock: ÁîüÊàêËØÑÂàÜ
    const totalScore = Math.floor(Math.random() * 30) + 70; // 70-100
    const result = db.prepare(`
      INSERT INTO scores (node_id, total_score, memory_score, logic_score, tool_score, quality_score, personality_score, action_taken)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      req.params.id,
      totalScore,
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      Math.floor(totalScore / 5),
      totalScore < 80 ? 'alert' : 'none'
    );

    // Êõ¥Êñ∞ËäÇÁÇπËØÑÂàÜ
    db.prepare('UPDATE nodes SET last_score = ? WHERE id = ?').run(totalScore, req.params.id);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'score', ?, ?)
    `).run(
      req.params.id, 
      totalScore < 80 ? 'warn' : 'info',
      `ËäÇÁÇπ ${req.params.id} Êô∫ÂäõÊµãËØïÂÆåÊàê: ${totalScore}/100`
    );

    const newScore = db.prepare('SELECT * FROM scores WHERE id = ?').get(result.lastInsertRowid);
    res.json({ 
      success: true, 
      score: newScore,
      message: `‚úÖ ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊÄªÂàÜ: ${totalScore}/100\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÈÄöËøá Bot ÂèëÈÄÅÊµãËØïÈ¢òÂπ∂Áî± LLM Judge ËØÑÂàÜ` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§Â§á‰ªΩ
app.post('/api/cluster/backup', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes WHERE status = ?').all('online');
    const count = nodes.length;

    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÂàõÂª∫Â§á‰ªΩ
    nodes.forEach(node => {
      db.prepare(`
        INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
        VALUES (?, 'auto', ?, ?, ?)
      `).run(
        node.id,
        Math.random().toString(36).substring(2, 9),
        Math.floor(Math.random() * 200) + 150,
        Math.floor(Math.random() * 10000000) + 8000000
      );
    });

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('backup', 'info', ?)
    `).run(`ÂÖ®ÈõÜÁæ§Â§á‰ªΩÂÆåÊàêÔºåÂÖ± ${count} ‰∏™ËäÇÁÇπ`);

    res.json({ 
      success: true, 
      count,
      message: `‚úÖ ÂÖ®ÈõÜÁæ§Â§á‰ªΩÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÂ∑≤Â§á‰ªΩ ${count} ‰∏™ËäÇÁÇπ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÂπ∂Ë°åÊâßË°å SSH Â§á‰ªΩÂπ∂Êé®ÈÄÅÂà∞ GitHub` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂÖ®ÈõÜÁæ§Êô∫ÂäõÊµãËØï
app.post('/api/cluster/test', (req, res) => {
  try {
    const nodes = db.prepare('SELECT * FROM nodes WHERE status = ?').all('online');
    const count = nodes.length;
    let totalScore = 0;

    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÁîüÊàêËØÑÂàÜ
    nodes.forEach(node => {
      const score = Math.floor(Math.random() * 30) + 70;
      totalScore += score;
      
      db.prepare(`
        INSERT INTO scores (node_id, total_score, memory_score, logic_score, tool_score, quality_score, personality_score, action_taken)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        node.id,
        score,
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        Math.floor(score / 5),
        score < 80 ? 'alert' : 'none'
      );

      db.prepare('UPDATE nodes SET last_score = ? WHERE id = ?').run(score, node.id);
    });

    const avgScore = Math.floor(totalScore / count);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('score', ?, ?)
    `).run(
      avgScore < 80 ? 'warn' : 'info',
      `ÂÖ®ÈõÜÁæ§ÊµãËØïÂÆåÊàêÔºåÂπ≥ÂùáÂàÜ: ${avgScore}/100`
    );

    res.json({ 
      success: true, 
      count,
      avgScore,
      message: `‚úÖ ÂÖ®ÈõÜÁæ§ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊµãËØïËäÇÁÇπ: ${count} ‰∏™\nÂπ≥ÂùáÂàÜ: ${avgScore}/100\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÂπ∂Ë°åÈÄöËøáÂêÑ Bot ÂèëÈÄÅÊµãËØïÈ¢ò` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈáçÂêØBot
app.post('/api/bots/:botId/restart', (req, res) => {
  try {
    const bot = db.prepare('SELECT * FROM bots WHERE id = ?').get(req.params.botId);
    if (!bot) return res.status(404).json({ error: 'Bot not found' });

    // Mock: Êõ¥Êñ∞Áä∂ÊÄÅ
    db.prepare('UPDATE bots SET status = ?, updated_at = ? WHERE id = ?')
      .run('running', Date.now(), req.params.botId);

    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'restart', 'info', ?)
    `).run(bot.node_id, `Bot ${bot.bot_name} Â∑≤ÈáçÂêØ`);

    res.json({ 
      success: true, 
      message: `‚úÖ Bot Â∑≤ÈáçÂêØÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊâßË°å SSH + kill + openclaw start` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Ê∏ÖÈô§‰∫ã‰ª∂Êó•Âøó
app.delete('/api/events', (req, res) => {
  try {
    const { days, severity } = req.query;
    let sql = 'DELETE FROM events WHERE 1=1';
    const params = [];

    if (days) {
      const timestamp = Date.now() - (parseInt(days) * 24 * 3600000);
      sql += ' AND created_at < ?';
      params.push(timestamp);
    }

    if (severity && severity !== 'all') {
      sql += ' AND severity = ?';
      params.push(severity);
    }

    const result = db.prepare(sql).run(...params);

    res.json({ 
      success: true, 
      deletedCount: result.changes,
      message: `‚úÖ Â∑≤Âà†Èô§ ${result.changes} Êù°‰∫ã‰ª∂ËÆ∞ÂΩï` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ============ Optimizations ÁÆ°ÁêÜ ============

// ÂàóË°®(ÂàÜÈ°µ+Áä∂ÊÄÅÁ≠õÈÄâ)
app.get('/api/optimizations', (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    
    const { status } = req.query;
    
    let whereClause = [];
    let params = [];
    
    if (status && status !== 'all') {
      whereClause.push('status = ?');
      params.push(status);
    }
    
    const whereSQL = whereClause.length > 0 ? 'WHERE ' + whereClause.join(' AND ') : '';
    
    const total = db.prepare(`SELECT COUNT(*) as count FROM optimizations ${whereSQL}`).get(...params).count;
    const optimizations = db.prepare(`
      SELECT * FROM optimizations 
      ${whereSQL}
      ORDER BY created_at DESC LIMIT ? OFFSET ?
    `).all(...params, limit, offset);
    
    // ÊØèÊù°ËÆ∞ÂΩïÊ∑ªÂä†ÂëΩ‰ª§Êï∞Èáè
    optimizations.forEach(opt => {
      opt.command_count = JSON.parse(opt.commands).length;
    });
    
    res.json({
      data: optimizations,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂàõÂª∫‰ºòÂåñ‰ªªÂä°
app.post('/api/optimizations', (req, res) => {
  try {
    const { title, description, commands, test_node_id } = req.body;
    const result = db.prepare(`
      INSERT INTO optimizations (title, description, commands, test_node_id)
      VALUES (?, ?, ?, ?)
    `).run(title, description || '', JSON.stringify(commands), test_node_id || 'macmini-02');
    
    const newOpt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(result.lastInsertRowid);
    res.json(newOpt);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ËØ¶ÊÉÖ
app.get('/api/optimizations/:id', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    opt.commands = JSON.parse(opt.commands);
    if (opt.test_result) opt.test_result = JSON.parse(opt.test_result);
    if (opt.deploy_progress) opt.deploy_progress = JSON.parse(opt.deploy_progress);
    res.json(opt);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞
app.put('/api/optimizations/:id', (req, res) => {
  try {
    const { title, description, commands, test_node_id } = req.body;
    db.prepare(`
      UPDATE optimizations 
      SET title = ?, description = ?, commands = ?, test_node_id = ?, updated_at = ?
      WHERE id = ?
    `).run(title, description, JSON.stringify(commands), test_node_id, Date.now(), req.params.id);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    res.json(updated);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§(‰ªÖdraftÁä∂ÊÄÅ)
app.delete('/api/optimizations/:id', (req, res) => {
  try {
    const opt = db.prepare('SELECT status FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    if (opt.status !== 'draft') {
      return res.status(400).json({ error: 'Âè™ËÉΩÂà†Èô§ËçâÁ®øÁä∂ÊÄÅÁöÑ‰ªªÂä°' });
    }
    
    db.prepare('DELETE FROM optimizations WHERE id = ?').run(req.params.id);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÈÉ®ÁΩ≤Âà∞ÊµãËØïÊú∫(mock: Â§á‰ªΩ‚ÜíÊâßË°åÂëΩ‰ª§‚ÜíÊô∫ÂäõÊµãËØï)
app.post('/api/optimizations/:id/test', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    
    // Mock: ÂàõÂª∫Â§á‰ªΩ
    const backupResult = db.prepare(`
      INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
      VALUES (?, 'pre-test', ?, ?, ?)
    `).run(
      opt.test_node_id,
      Math.random().toString(36).substring(2, 9),
      Math.floor(Math.random() * 200) + 150,
      Math.floor(Math.random() * 10000000) + 8000000
    );
    
    // Mock: Ê®°ÊãüÊµãËØïÔºàÈöèÊú∫ 65-95 ÂàÜÔºâ
    const testScore = Math.floor(Math.random() * 30) + 65;
    const testResult = {
      memory: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      logic: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      tool: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      quality: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
      personality: Math.floor(testScore / 5) + Math.floor(Math.random() * 3 - 1),
    };
    
    const newStatus = testScore >= 80 ? 'test_passed' : 'test_failed';
    
    db.prepare(`
      UPDATE optimizations 
      SET status = ?, test_backup_id = ?, test_score = ?, test_result = ?, updated_at = ?
      WHERE id = ?
    `).run(newStatus, backupResult.lastInsertRowid, testScore, JSON.stringify(testResult), Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (node_id, type, severity, message)
      VALUES (?, 'optimization', ?, ?)
    `).run(
      opt.test_node_id,
      testScore >= 80 ? 'info' : 'warn',
      `‰ºòÂåñ‰ªªÂä° "${opt.title}" ÊµãËØïÂÆåÊàê: ${testScore}/100 (${newStatus === 'test_passed' ? 'ÈÄöËøá' : 'Â§±Ë¥•'})`
    );
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    updated.test_result = JSON.parse(updated.test_result);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÊµãËØïÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊµãËØïÂæóÂàÜ: ${testScore}/100\nÁä∂ÊÄÅ: ${newStatus === 'test_passed' ? '‚úÖ ÈÄöËøá' : '‚ùå Â§±Ë¥•'}`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÊªöÂä®ÈÉ®ÁΩ≤Âà∞Áîü‰∫ßËäÇÁÇπ(mock)
app.post('/api/optimizations/:id/deploy', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    if (opt.status !== 'test_passed') {
      return res.status(400).json({ error: 'Âè™ËÉΩÈÉ®ÁΩ≤ÊµãËØïÈÄöËøáÁöÑ‰ªªÂä°' });
    }
    
    // Mock: Ëé∑ÂèñÊâÄÊúâÂú®Á∫øËäÇÁÇπÔºàÈô§‰∫ÜÊµãËØïËäÇÁÇπÔºâ
    const nodes = db.prepare('SELECT id FROM nodes WHERE status = ? AND id != ?')
      .all('online', opt.test_node_id);
    
    const { target_nodes } = req.body; // ÂèØÈÄâÔºöÊåáÂÆöË¶ÅÈÉ®ÁΩ≤ÁöÑËäÇÁÇπ
    const deployNodes = target_nodes || nodes.map(n => n.id);
    
    // Mock: ‰∏∫ÊØè‰∏™ËäÇÁÇπÂàõÂª∫ÈÉ®ÁΩ≤ËøõÂ∫¶
    const deployProgress = deployNodes.map(nodeId => {
      const backupResult = db.prepare(`
        INSERT INTO backups (node_id, type, git_commit, file_count, total_size)
        VALUES (?, 'pre-deploy', ?, ?, ?)
      `).run(
        nodeId,
        Math.random().toString(36).substring(2, 9),
        Math.floor(Math.random() * 200) + 150,
        Math.floor(Math.random() * 10000000) + 8000000
      );
      
      const score = Math.floor(Math.random() * 15) + 85; // 85-100
      
      return {
        node_id: nodeId,
        status: 'deployed',
        backup_id: backupResult.lastInsertRowid,
        score: score
      };
    });
    
    db.prepare(`
      UPDATE optimizations 
      SET status = 'deployed', deploy_progress = ?, completed_at = ?, updated_at = ?
      WHERE id = ?
    `).run(JSON.stringify(deployProgress), Date.now(), Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('optimization', 'info', ?)
    `).run(`‰ºòÂåñ‰ªªÂä° "${opt.title}" Â∑≤ÈÉ®ÁΩ≤Âà∞ ${deployNodes.length} ‰∏™Áîü‰∫ßËäÇÁÇπ`);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    updated.deploy_progress = JSON.parse(updated.deploy_progress);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÈÉ®ÁΩ≤ÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÂ∑≤ÈÉ®ÁΩ≤ËäÇÁÇπ: ${deployNodes.length} ‰∏™`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ÂõûÊªö(mock)
app.post('/api/optimizations/:id/rollback', (req, res) => {
  try {
    const opt = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    if (!opt) {
      return res.status(404).json({ error: 'Optimization not found' });
    }
    
    db.prepare(`
      UPDATE optimizations 
      SET status = 'rollback', updated_at = ?
      WHERE id = ?
    `).run(Date.now(), req.params.id);
    
    // Ê∑ªÂä†‰∫ã‰ª∂
    db.prepare(`
      INSERT INTO events (type, severity, message)
      VALUES ('optimization', 'warn', ?)
    `).run(`‰ºòÂåñ‰ªªÂä° "${opt.title}" Â∑≤ÂõûÊªö`);
    
    const updated = db.prepare('SELECT * FROM optimizations WHERE id = ?').get(req.params.id);
    
    res.json({
      success: true,
      optimization: updated,
      message: `‚úÖ ÂõûÊªöÂÆåÊàêÔºàÊºîÁ§∫Ê®°ÂºèÔºâ`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ‰øùÂ≠òËÆæÁΩÆ
app.put('/api/settings', (req, res) => {
  try {
    // Mock: Âú®ÂÆûÈôÖÁéØÂ¢É‰∏≠‰ºöÂÜôÂÖ•ÈÖçÁΩÆÊñá‰ª∂
    const settings = req.body;
    
    // Ê∑ªÂä†ÂÆ°ËÆ°Êó•Âøó
    db.prepare(`
      INSERT INTO audit_log (operator, action, target, result, duration_ms)
      VALUES ('web', 'update_settings', 'system', 'success', 0)
    `).run();

    res.json({ 
      success: true, 
      message: `‚úÖ ËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºàÊºîÁ§∫Ê®°ÂºèÔºâ\nÊèêÁ§∫ÔºöÂÆûÈôÖÁéØÂ¢É‰ºöÊõ¥Êñ∞ config.json Âπ∂ÈáçÂêØÁõ∏ÂÖ≥ÊúçÂä°` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve static files (client build)
app.use(express.static(path.join(__dirname, '..', 'client', 'dist')));

// SPA fallback
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '..', 'client', 'dist', 'index.html'));
});

app.listen(PORT, () => {
  console.log(`üöÄ OCM Server running on http://localhost:${PORT}`);
});
